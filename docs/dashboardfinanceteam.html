<!DOCTYPE html>
<html lang="en" class="light-style layout-menu-fixed" dir="ltr" data-theme="theme-default" data-assets-path="/Contract_Management_Lifecycle_frontend/vuexy-bootstrap-html-admin-template/full-version/valuess/" data-template="vertical-menu-template">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accordwise</title>
    <!-- Core CSS (Vuexy/bootstrap 5) -->
    <link rel="stylesheet" href="/Contract_Management_Lifecycle_frontend/vuexy-bootstrap-html-admin-template/full-version/valuess/css/core.css">
    <!-- Vendors CSS -->
    <link rel="stylesheet" href="/Contract_Management_Lifecycle_frontend/vuexy-bootstrap-html-admin-template/full-version/valuess/libs/perfect-scrollbar/perfect-scrollbar.css">
    <link rel="stylesheet" href="/Contract_Management_Lifecycle_frontend/vuexy-bootstrap-html-admin-template/full-version/valuess/libs/node-waves/node-waves.css">
    <!-- FontAwesome for Icons -->
    <link rel="stylesheet" href="/Contract_Management_Lifecycle_frontend/vuexy-bootstrap-html-admin-template/full-version/valuess/fonts/fontawesome.css">
    <!-- Suppress favicon error -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="config.js"></script>
    <link rel="icon" href="data:,">
    <style>
        .editor-container {
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 10px;
            min-height: 300px;
            width: 100%;
            height: 500px; /* Adjust height for OnlyOffice */
        }
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .action-btn {
            padding: 4px 8px;
        }
        .btn-outline-primary { background-color: rgba(13, 110, 253, 0.1); }
        .btn-outline-success { background-color: rgba(25, 135, 84, 0.1); }
        .btn-outline-info { background-color: rgba(13, 202, 240, 0.1); }
        .btn-outline-danger { background-color: rgba(220, 53, 69, 0.1); }
        #contentArea { position: relative; min-height: 500px; }
        .editor-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; padding: 10px; box-sizing: border-box; background: white; }
        .editor-wrapper { width: 100%; height: calc(100% - 50px); margin-top: 50px; }
        .editor-btns { position: absolute; top: 10px; right: 10px; z-index: 10; display: flex; gap: 10px; }
        .action-buttons { display: flex; flex-direction: column; gap: 5px; }
        .action-btn { padding: 4px 8px; }
        .btn-outline-primary { background-color: rgba(13, 110, 253, 0.1); }
        .btn-outline-success { background-color: rgba(25, 135, 84, 0.1); }
        .btn-outline-info { background-color: rgba(13, 202, 240, 0.1); }
        .btn-outline-danger { background-color: rgba(220, 53, 69, 0.1); }
        .modal-dialog { max-width: 90%; }
        #templatesContent.hidden {
        display: none;
    }
    #templatesContentHidden {
        display: none;
    }
        .menu-sub {
    display: none; /* Hidden by default */
}
/* Modal Popup Styles */
.pdf-editor-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 2000;
    justify-content: center;
    align-items: center;
}

.pdf-editor-content {
    background-color: white;
    width: 90%;
    max-width: 1000px;
    height: 80%;
    border-radius: 8px;
    padding: 20px;
    position: relative;
    overflow: auto;
}

.pdf-editor-content .close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
    background: none;
    border: none;
}

#pdf-viewer-container {
    position: relative;
    width: 100%;
    height: calc(100% - 60px); /* Adjust for controls */
    overflow: auto;
}

#pdf-controls {
    margin-bottom: 10px;
}

#pdf-controls button {
    margin-right: 10px;
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#pdf-controls button:hover {
    opacity: 0.9;
}

#render-canvas {
    border: 1px solid #ccc;
}

#fabric-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1001;
}
.menu-item.active .menu-sub {
    display: block; /* Shown when parent is active */
}

        .menu-sub {
    display: none; /* Hidden by default */
}
#myApprovalsLink + .menu-sub {
    display: block !important; /* Always show My Approvals submenu */
}
#contractsLink + .menu-sub {
    display: block !important; /* Always show Contracts submenu */
} 
.menu-sub.show {
    display: block !important; /* Always shown when 'show' class is present */
}
.approval-container, .signature-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    position: relative;
}

.approval-box, .signature-box {
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #f9f9f9;
    cursor: move;
    position: relative;
    transition: transform 0.3s ease;
}

.approval-box.dragging, .signature-box.dragging {
    opacity: 0.5;
    transform: scale(0.98);
}

.member-entry, .approval-entry {
    margin-bottom: 10px;
}

hr.my-4 {
    border: 1px solid #ccc;
    margin: 20px 0;
}

#main-content {
    position: relative;
}

#pdf-editor {
    position: relative;
    width: 100%;
    height: 100%;
}

#pdf-controls {
    margin-bottom: 10px;
}

#pdf-viewer {
    position: relative;
    width: 100%;
    border: 1px solid #ccc;
}

#fabric-canvas {
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid #000;
}
/* Calendar Styles */
/* Calendar and Side Panel Container */
.calendar-container {
    max-width: 100%;
    margin: 0 auto;
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
}

/* Calendar Styles */
.fc {
    font-size: 14px;
    flex: 1;
    min-width: 600px;
}
.fc-daygrid-day.fc-day-highlighted {
    position: relative;
    background: linear-gradient(135deg, rgba(var(--bs-primary-rgb), 0.15), rgba(var(--bs-primary-rgb), 0.05)) !important; /* Subtle primary gradient */
    border: 2px solid var(--bs-primary) !important; /* Primary blue border */
    border-radius: var(--bs-border-radius); /* Match card border-radius */
    box-shadow: var(--bs-box-shadow-sm) !important; /* Subtle shadow */
}
.fc-daygrid-day.fc-day-highlighted::before {
    content: '!';
    position: absolute;
    top: 5px;
    left: 5px;
    width: 14px;
    height: 14px;
    background-color: var(--bs-danger); /* Red badge for urgency */
    color: var(--bs-white);
    border-radius: 50%;
    font-size: 9px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
}
.fc-daygrid-day.fc-day-highlighted .fc-daygrid-day-number {
    color: var(--bs-primary); /* Primary blue text */
    font-weight: bold; /* Bootstrap fw-bold */
}

/* Event (Contract Title) Styles */
.fc-event {
    cursor: pointer;
    background-color: var(--bs-primary); /* Bootstrap primary blue */
    color: var(--bs-white) !important;
    padding: 4px 10px; /* Comfortable padding */
    border-radius: 1rem; /* Bootstrap rounded-pill */
    font-size: 0.875rem; /* Bootstrap fs-6 */
    font-weight: 500; /* Bootstrap fw-medium */
    box-shadow: var(--bs-box-shadow-sm); /* Subtle shadow */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 90%; /* Prevent overflow */
    transition: background-color 0.2s ease, box-shadow 0.2s ease; /* Smooth hover */
}
.fc-event:hover {
    background-color: #0056b3; /* Darker primary shade */
    box-shadow: var(--bs-box-shadow); /* Slightly larger shadow */
}

/* Side Panel Styles */
.side-panel {
    flex: 0 0 400px;
    background: var(--bs-white);
    box-shadow: var(--bs-box-shadow);
    padding: 20px;
    border-radius: var(--bs-border-radius);
    display: none;
    position: relative;
}
.side-panel.open {
    display: block;
}
.side-panel .close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
    background: none;
    border: none;
    color: var(--bs-dark);
}
.side-panel .close-btn:hover {
    color: var(--bs-primary);
}
.side-panel h5 {
    margin-bottom: 20px;
}
.side-panel .contract-details p {
    margin: 10px 0;
}

/* Tab Styles (unchanged) */
.nav-tabs .nav-link {
    cursor: pointer;
}
.tab-content {
    padding: 20px;
}
.accounts-tab, .all-accounts-tab {
    margin-top: 20px;
}
.accounts-table {
    margin-top: 20px;
}

    </style>
</head>
<body>
    <!-- Layout Wrapper -->
    <div class="layout-wrapper layout-content-navbar">
        <div class="layout-container">
            <!-- Sidebar (Menu) -->
            <aside id="sidebar" class="layout-menu menu-vertical menu bg-menu-theme">
                <div class="app-brand p-3">
                    <a href="#" class="app-brand-link">
                        <span class="app-brand-text demo menu-text fw-bold ms-2">Accordwise</span>
                    </a>
                    <a href="javascript:void(0);" id="closeSidebar" class="layout-menu-toggle menu-link text-large ms-auto">
                        <i class="fas fa-times menu-toggle-icon"></i>
                    </a>
                </div>
                <div class="menu-inner-shadow"></div>
                <ul class="menu-inner py-1">
                    <li class="menu-item active">
                        <a href="#" class="menu-link" id="dashboardLink">
                            <i class="menu-icon tf-icons fas fa-tachometer-alt"></i>
                            <div>Dashboard</div>
                        </a>
                    </li>
                    <li class="menu-item ">
                        <a href="#" class="menu-link" id="templatesLink">
                            <i class="menu-icon tf-icons fas fa-table"></i>
                            <div>Templates</div>
                        </a>
                    </li>
                    <li class="menu-item">
                        <a href="#" class="menu-link" id="workflowLink">
                            <i class="menu-icon tf-icons fas fa-cogs"></i>
                            <div>Workflow</div>
                        </a>
                    </li>
                    <li class="menu-item ">
                        <a href="#" class="menu-link menu-toggle" id="contractsLink">
                            <i class="menu-icon tf-icons fas fa-file-contract"></i>
                            <div>Contracts</div>
                        </a>
                        <ul class="menu-sub">
                            <li class="menu-item">
                                <a href="#" class="menu-link" id="contractsInProgressLink">
                                    <div>In Progress</div>
                                </a>
                            </li>
                            <li class="menu-item">
                                <a href="#" class="menu-link" id="contractsCompletedLink">
                                    <div>Completed</div>
                                </a>
                            </li>
                        </ul>
                    </li>
                    <li class="menu-item">
                        <a href="#" class="menu-link" id="myCoDraftsLink">
                            <i class="menu-icon tf-icons fas fa-users"></i>
                            <div>My Co-Drafts</div>
                        </a>
                    </li>
                    <li class="menu-item">
                        <a href="#" class="menu-link menu-toggle" id="myApprovalsLink">
                            <i class="menu-icon tf-icons fas fa-check-circle"></i>
                            <div>My Approvals</div>
                        </a>
                        <ul class="menu-sub">
                            <li class="menu-item">
                                <a href="#" class="menu-link" id="reviewersLink">
                                    <div>Reviewers</div>
                                </a>
                            </li>
                            <li class="menu-item">
                                <a href="#" class="menu-link" id="signaturesLink">
                                    <div>Signatures</div>
                                </a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </aside>

            <!-- Layout Page -->
            <div id="mainContent" class="layout-page">
                <!-- Navbar (Top Bar) -->
                <nav class="layout-navbar container-xxl navbar navbar-expand-xl navbar-detached align-items-center bg-navbar-theme" id="layout-navbar">
                    <div class="navbar-nav-right d-flex align-items-center">
                        <button id="openSidebar" class="btn btn-icon me-2 d-xl-none">
                            <i class="fas fa-bars"></i>
                        </button>
                        <ul class="navbar-nav flex-row align-items-center ms-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="javascript:void(0)">
                                    <i class="fas fa-cog"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="javascript:void(0)">
                                    <i class="fas fa-user-circle"></i>
                                </a>
                            </li>
                        </ul>
                    </div>
                </nav>

                <!-- Content Wrapper -->
                <div class="content-wrapper">
                    <div class="container-xxl flex-grow-1 container-p-y" id="contentArea">
                        <!-- Templates Table -->
                        <div id="templatesContentHidden" style="display: none;">
                            <div class="mb-3">
                                <input type="text" class="form-control" id="templateFilter" placeholder="Filter by template name...">
                            </div>
                            <div class="card">
                                <div class="card-header">Templates</div>
                                <div class="card-body">
                                    <div class="table-responsive">
                                        <table class="table table-striped">
                                            <thead>
                                                <tr>
                                                    <th>Template Name</th>
                                                    <th>Version</th>
                                                    <th>Last Updated On</th>
                                                    <th>Status</th>
                                                    <th>Action</th>
                                                </tr>
                                            </thead>
                                            <tbody id="templatesTableBody"></tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Dashboard Content (Initial Load) -->
        <div id="templatesContent">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Dashboard</h5>
                </div>
                <div class="card-body">
                    <ul class="nav nav-tabs" id="dashboardTabs" role="tablist">
                        <li class="nav-item">
                            <a class="nav-link active" id="upcoming-events-tab" data-bs-toggle="tab" href="#upcoming-events" role="tab">Upcoming Events</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" id="accounts-tab" data-bs-toggle="tab" href="#accounts" role="tab">Accounts</a>
                        </li>
                    </ul>
                    <div class="tab-content" id="dashboardTabContent">
                        <div class="tab-pane fade show active" id="upcoming-events" role="tabpanel">
                            <div class="calendar-container">
                                <div id="calendar"></div>
                                <div class="side-panel" id="contractDetailsPanel">
                                    <button class="close-btn" id="closePanelBtn">×</button>
                                    <h5>Contract Details</h5>
                                    <div class="contract-details" id="contractDetails"></div>
                                </div>
                            </div>
                        </div>
                        <div class="tab-pane fade accounts-tab" id="accounts" role="tabpanel">
                            <select id="accountSelect" class="form-select mb-3">
                                <option value="">Select Account</option>
                            </select>
                            <div class="accounts-table">
                                <div class="table-responsive">
                                    <table class="table table-bordered table-hover">
                                        <thead class="table-light">
                                            <tr>
                                                <th>Contract Title</th>
                                                <th>Created On</th>
                                                <th>Updated On</th>
                                                <th>Action</th>
                                            </tr>
                                        </thead>
                                        <tbody id="accountsTableBody"></tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
                        <div id="fullScreenEditor" class="editor-container" style="display: none;">
                            <div id="editorButtons" class="editor-btns"></div>
                            <div id="editorWrapper" class="editor-wrapper"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Core JS Files -->
    <script src="/Contract_Management_Lifecycle_frontend/vuexy-bootstrap-html-admin-template/full-version/valuess/libs/popper/popper.js"></script>
    <script src="/Contract_Management_Lifecycle_frontend/vuexy-bootstrap-html-admin-template/full-version/valuess/js/bootstrap.js"></script>
    <script src="/Contract_Management_Lifecycle_frontend/vuexy-bootstrap-html-admin-template/full-version/valuess/libs/perfect-scrollbar/perfect-scrollbar.js"></script>

    <!-- Dependency Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script type="text/javascript" src="http://192.168.4.37/web-apps/apps/api/documents/api.js"></script>
    <script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
    <script src="https://unpkg.com/mammoth@1.4.2/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <!-- Application Logic -->
    <script>
        let supabaseClient;
        let createEditor = null;
        let pendingTemplate = null;
        let currentEditingTemplate = null;

        const jwt = {
            sign: function(payload, secret) {
                const header = { alg: 'HS256', typ: 'JWT' };
                const base64UrlEncode = (str) => btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                const encodedHeader = base64UrlEncode(JSON.stringify(header));
                const encodedPayload = base64UrlEncode(JSON.stringify(payload));
                const signature = CryptoJS.HmacSHA256(`${encodedHeader}.${encodedPayload}`, secret).toString(CryptoJS.enc.Base64url);
                return `${encodedHeader}.${encodedPayload}.${signature}`;
            }
        };

        function waitForDependencies() {
            console.log('Checking dependencies - Supabase:', typeof supabase !== 'undefined', 'DocsAPI:', typeof DocsAPI !== 'undefined', 'CryptoJS:', typeof CryptoJS !== 'undefined');
            if (typeof supabase !== 'undefined' && typeof DocsAPI !== 'undefined' && typeof CryptoJS !== 'undefined') {
                console.log('All dependencies loaded, initializing app');
                initializeApp();
            } else {
                console.log('Waiting for dependencies...');
                setTimeout(waitForDependencies, 100);
            }
        }
        async function initializeApp() {
    console.log('Starting app initialization');
    const { supabaseUrl, supabaseKey } = window.ENV;
    supabaseClient = supabase.createClient(supabaseUrl, supabaseKey, {
        fetch: (...args) => fetch(...args, { headers: { 'Accept': 'application/json' } })
    });
    console.log('Supabase client initialized');

    const currentUserUsername = localStorage.getItem('loggedInAdminUsername');
    const userRole = localStorage.getItem('loggedInRole');
    console.log('Logged in user:', { username: currentUserUsername, role: userRole });
    if (!currentUserUsername || !userRole) {
        alert('Please log in first!');
        window.location.href = 'login.html';
        return;
    }

    const { data: userData, error: userError } = await supabaseClient
        .from('users')
        .select('organisation')
        .eq('username', currentUserUsername)
        .single();
    console.log('User data fetch result:', { data: userData, error: userError });
    if (userError || !userData) {
        alert('Error fetching user organization.');
        console.error('User fetch error:', userError);
        return;
    }
    const organisationname = userData.organisation;
            localStorage.setItem('loggedInOrganisationName', organisationname);
            const organisationName = userData.organisation.toLowerCase().replace(/[^a-z0-9_]/g, '_');
            const templatesTableName = `${organisationName}_templates`;
            const documentsTableName = organisationName;
            console.log('Derived table names:', { templatesTableName, documentsTableName });

    const sidebar = document.getElementById('sidebar');
    document.getElementById('openSidebar').onclick = function() { sidebar.classList.remove('layout-menu-hidden'); };
    document.getElementById('closeSidebar').onclick = function() { sidebar.classList.add('layout-menu-hidden'); };

    fetchTemplates(templatesTableName);

    document.getElementById('templateFilter').addEventListener('input', function() {
        const filterValue = this.value.toLowerCase();
        filterTemplates(templatesTableName, filterValue);
    });

    document.getElementById('templatesLink').addEventListener('click', function(e) {
        e.preventDefault();
        showTemplates(templatesTableName);
    });

    document.getElementById('reviewersLink').addEventListener('click', function(e) {
        e.preventDefault();
        showReviewers(this);
    });

    document.getElementById('signaturesLink').addEventListener('click', function(e) {
        e.preventDefault();
        showSignatures(this);
    });
}

async function showTemplates(templatesTableName) {
    console.log('showTemplates called for table:', templatesTableName);
    const templatesContent = document.getElementById('templatesContent');
    const editorContainer = document.getElementById('fullScreenEditor');
    const templatesContentHidden = document.getElementById('templatesContentHidden');
    const menuItems = document.querySelectorAll('.menu-item');

    if (!templatesContent) {
        console.error('Error: #templatesContent not found in showTemplates');
        alert('Error: Content area not found. Please contact support.');
        return;
    }

    // Update active menu item
    menuItems.forEach(item => item.classList.remove('active'));
    const templatesLink = document.getElementById('templatesLink');
    if (templatesLink && templatesLink.parentElement) {
        templatesLink.parentElement.classList.add('active');
    } else {
        console.warn('templatesLink or its parent not found');
    }

    // Hide editor
    editorContainer.style.display = 'none';

    // Load Templates content from hidden div
    console.log('Loading templates HTML');
    if (templatesContentHidden) {
        templatesContent.innerHTML = templatesContentHidden.innerHTML;
        console.log('Templates HTML loaded from templatesContentHidden');
    } else {
        console.warn('templatesContentHidden not found, using fallback HTML');
        templatesContent.innerHTML = `
            <div class="mb-3">
                <input type="text" class="form-control" id="templateFilter" placeholder="Filter by template name...">
            </div>
            <div class="card">
                <div class="card-header">Templates</div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-striped">
                            <thead>
                                <tr>
                                    <th>Template Name</th>
                                    <th>Version</th>
                                    <th>Last Updated On</th>
                                    <th>Status</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody id="templatesTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
    }

    // Ensure templatesContent is visible
    templatesContent.classList.remove('hidden');

    // Verify templatesTableBody exists
    const templatesTableBody = document.getElementById('templatesTableBody');
    if (!templatesTableBody) {
        console.error('Error: #templatesTableBody not found after loading templates HTML');
        alert('Error: Templates table not found. Please contact support.');
        return;
    }
    console.log('templatesTableBody found:', templatesTableBody);

    // Fetch and render templates
    console.log('Calling fetchTemplates');
    try {
        await fetchTemplates(templatesTableName);
        console.log('fetchTemplates completed');
    } catch (err) {
        console.error('Error in fetchTemplates:', err);
        alert('Failed to load templates: ' + err.message);
    }

    // Attach filter event listener
    const templateFilter = document.getElementById('templateFilter');
    if (templateFilter) {
        // Remove existing listeners to prevent duplicates
        templateFilter.replaceWith(templateFilter.cloneNode(true));
        const newTemplateFilter = document.getElementById('templateFilter');
        newTemplateFilter.addEventListener('input', () => {
            console.log('templateFilter input event triggered');
            filterTemplates(templatesTableName, newTemplateFilter.value.toLowerCase());
        });
        console.log('templateFilter event listener attached');
    } else {
        console.warn('templateFilter not found after loading templates');
    }
}
        async function fetchTemplates(tableName) {
            console.log('Fetching templates from table:', tableName);
            try {
                const { data, error } = await supabaseClient
                    .from(tableName)
                    .select('template_id, template_name, version, last_updated_on, status, storage_path')
                    .eq('status_del', 1)
                    .eq('status', 'published')
                    .order('last_updated_on', { ascending: false });
                console.log('Fetch templates result:', { data, error });
                if (error) throw new Error(`Failed to fetch templates: ${error.message}`);
                renderTemplates(data, tableName);
            } catch (err) {
                console.error('Error fetching templates:', err);
                alert(`Error: ${err.message}`);
            }
        }

        async function filterTemplates(tableName, filterValue) {
            console.log('Filtering templates:', { tableName, filterValue });
            try {
                const { data, error } = await supabaseClient
                    .from(tableName)
                    .select('template_id, template_name, version, last_updated_on, status, storage_path')
                    .eq('status_del', 1)
                    .eq('status', 'published')
                    .ilike('template_name', `%${filterValue}%`)
                    .order('last_updated_on', { ascending: false });
                console.log('Filter templates result:', { data, error });
                if (error) throw new Error(`Failed to filter templates: ${error.message}`);
                renderTemplates(data, tableName);
            } catch (err) {
                console.error('Error filtering templates:', err);
                alert(`Error: ${err.message}`);
            }
        }

        async function downloadFile(storagePath, fileName) {
            console.log('Downloading file:', { storagePath, fileName });
            try {
                const url = `http://localhost:3000/get-file?filePath=${encodeURIComponent(storagePath)}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to fetch file: ${await response.text()}`);
                const { content: base64Content } = await response.json();
                const blob = base64ToBlob(base64Content, 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log('File downloaded successfully');
            } catch (err) {
                console.error('Error downloading file:', err);
                alert(`Error: ${err.message}`);
            }
        }

        function renderTemplates(data, tableName) {
            console.log('Rendering templates for table:', tableName, 'Data:', data);
            const tbody = document.getElementById('templatesTableBody');
            tbody.innerHTML = '';
            if (data && data.length > 0) {
                data.forEach(template => {
                    const row = document.createElement('tr');
                    const statusBadgeClass = 'badge bg-label-success'; // Always published
                    row.innerHTML = `
                        <td>${template.template_name}</td>
                        <td>${template.version}</td>
                        <td>${new Date(template.last_updated_on).toLocaleString()}</td>
                        <td><span class="${statusBadgeClass}">${template.status}</span></td>
                        <td>
                            <button class="btn btn-sm btn-outline-success download-btn" 
                                    data-storage-path="${template.storage_path}" 
                                    title="Download">
                                <i class="fas fa-download"></i>
                            </button>
                        </td>
                    `;
                    tbody.appendChild(row);

                    row.querySelector('.download-btn').addEventListener('click', () => {
                        const storagePath = row.querySelector('.download-btn').dataset.storagePath;
                        downloadFile(storagePath, `${template.template_name}_${template.version}.docx`);
                    });
                });
            } else {
                tbody.innerHTML = '<tr><td colspan="5" class="text-center">No published templates found.</td></tr>';
            }
        }

        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            return new Blob([new Uint8Array(byteNumbers)], { type: mimeType });
        }
        async function showReviewers(element) {
    const menuItems = document.querySelectorAll('.menu-item');
    menuItems.forEach(item => item.classList.remove('active'));
    element.parentElement.classList.add('active');
    const myApprovalsMenu = document.getElementById('myApprovalsLink').parentElement;
    myApprovalsMenu.classList.add('active');
    const submenu = myApprovalsMenu.querySelector('.menu-sub');
    submenu.style.display = 'block';

    const templatesContent = document.getElementById('templatesContent');
    const editorContainer = document.getElementById('fullScreenEditor');

    if (!editorContainer) {
        console.error('fullScreenEditor element not found in DOM');
        templatesContent.innerHTML = `<div class="card"><div class="card-body">Error: Editor container not found</div></div>`;
        return;
    }
    editorContainer.style.display = 'none';
    templatesContent.classList.remove('hidden');

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    const loggedInUsername = localStorage.getItem('loggedInAdminUsername');
    if (!organisationName || !loggedInUsername) {
        alert('No user logged in. Please log in first.');
        window.location.href = 'login.html';
        return;
    }

    try {
        // Fetch user details
        const { data: userData, error: userError } = await supabaseClient
            .from('users')
            .select('team_type, role, email, organisation')
            .eq('username', loggedInUsername)
            .eq('organisation', organisationName)
            .single();
        if (userError || !userData) {
            throw new Error(`Failed to fetch user details: ${userError?.message || 'No user found'}`);
        }
        const { team_type, role, email } = userData;
        const isLegalOrFinancial = team_type === 'Legal Team' || team_type === 'Finance Team';

        templatesContent.innerHTML = `
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Reviewers</h5>
                </div>
                <div class="card-body">
                    <ul class="nav nav-tabs" id="reviewersTabs" role="tablist">
                        <li class="nav-item">
                            <a class="nav-link active" id="contract-creation-tab" data-bs-toggle="tab" href="#contract-creation" role="tab">Contract Creation</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" id="contract-modification-tab" data-bs-toggle="tab" href="#contract-modification" role="tab">Contract Modification</a>
                        </li>
                        ${isLegalOrFinancial ? `
                        <li class="nav-item">
                            <a class="nav-link" id="contract-cancellation-tab" data-bs-toggle="tab" href="#contract-cancellation" role="tab">Contract Cancellation</a>
                        </li>
                        ` : ''}
                    </ul>
                    <div class="tab-content" id="reviewersTabContent">
                        <div class="tab-pane fade show active" id="contract-creation" role="tabpanel">
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <thead class="table-light">
                                        <tr>
                                            <th>Agreement Title</th>
                                            <th>Requested By</th>
                                            <th>Account Name</th>
                                            <th>Created On</th>
                                            <th>Updated On</th>
                                            <th>Action</th>
                                        </tr>
                                    </thead>
                                    <tbody id="reviewersTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="tab-pane fade" id="contract-modification" role="tabpanel">
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <thead class="table-light">
                                        <tr>
                                            <th>Agreement Title</th>
                                            <th>Requested By</th>
                                            <th>Account Name</th>
                                            <th>Created On</th>
                                            <th>Updated On</th>
                                            <th>Action</th>
                                        </tr>
                                    </thead>
                                    <tbody id="modificationTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                        ${isLegalOrFinancial ? `
                        <div class="tab-pane fade" id="contract-cancellation" role="tabpanel">
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <thead class="table-light">
                                        <tr>
                                            <th>Agreement Title</th>
                                            <th>Requested By</th>
                                            <th>Account Name</th>
                                            <th>Created On</th>
                                            <th>Updated On</th>
                                            <th>Action</th>
                                        </tr>
                                    </thead>
                                    <tbody id="cancellationTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;

        await populateReviewersTable(organisationName, team_type, role, email, isLegalOrFinancial);
    } catch (err) {
        console.error('Error in showReviewers:', err);
        templatesContent.innerHTML = `<div class="card"><div class="card-body">Error: ${err.message}</div></div>`;
    }
}

/* New function to populate both tabs */
async function populateReviewersTable(organisationName, teamType, role, email, isLegalOrFinancial) {
    const contractsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;
    const metadataTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_metadatacontract`;
    const cancellationTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contractcancellation`;
    const creationTbody = document.getElementById('reviewersTableBody');
    const modificationTbody = document.getElementById('modificationTableBody');
    let cancellationTbody = null;
    if (isLegalOrFinancial) {
        cancellationTbody = document.getElementById('cancellationTableBody');
    }

    try {
        // Fetch contracts for Contract Creation tab
        const { data: creationContracts, error: creationError } = await supabaseClient
            .from(contractsTableName)
            .select('id, cid, title, requested_by, accountname, createdon, updatedon, storage_path, iapprovedby, approved_email, team')
            .eq('stage', 'Under Review – Internal')
            .eq('status', 'In Progress')
            .eq('valid', 'Pending')
            .eq('team', teamType);
        if (creationError) {
            throw new Error(`Failed to fetch creation contracts: ${creationError.message}`);
        }

        // Filter contracts based on iapprovedby conditions
        const filteredCreationContracts = creationContracts.filter(contract => {
            if (contract.team !== teamType) return false;
            if (contract.iapprovedby === 'Team Head') {
                return role === 'head';
            } else if (contract.iapprovedby === 'Any Team Member') {
                return true;
            } else if (contract.iapprovedby === 'Specific Team Member') {
                return contract.approved_email === email;
            }
            return false;
        });

        // Render filtered contracts for Contract Creation tab
        creationTbody.innerHTML = '';
        if (filteredCreationContracts.length > 0) {
            filteredCreationContracts.forEach(contract => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${contract.title}</td>
                    <td>${contract.requested_by}</td>
                    <td>${contract.accountname}</td>
                    <td>${new Date(contract.createdon).toLocaleString()}</td>
                    <td>${new Date(contract.updatedon).toLocaleString()}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary review-btn" 
                                data-id="${contract.id}"
                                data-cid="${contract.cid}" 
                                data-storage-path="${contract.storage_path}" 
                                data-title="${contract.title}">
                            Review
                        </button>
                    </td>
                `;
                creationTbody.appendChild(row);

                row.querySelector('.review-btn').addEventListener('click', () => {
                    openReviewDocument(contract.id, contract.cid, contract.storage_path, contract.title, contractsTableName);
                });
            });
        } else {
            creationTbody.innerHTML = '<tr><td colspan="6" class="text-center">No contracts to review.</td></tr>';
        }
        // Fetch contracts for Contract Modification tab
        const { data: modificationContracts, error: modificationError } = await supabaseClient
            .from(contractsTableName)
            .select('id, cid, title, requested_by, accountname, createdon, updatedon, new_storage_path, iapprovedby, approved_email, team')
            .eq('stage', 'Extension Draft - Internal Approval')
            .eq('status', 'In Progress')
            .eq('valid', 'Pending')
            .eq('team', teamType);
        if (modificationError) {
            throw new Error(`Failed to fetch modification contracts: ${modificationError.message}`);
        }

        // Filter contracts for Contract Modification tab
        const filteredModificationContracts = modificationContracts.filter(contract => {
            if (contract.team !== teamType) return false;
            if (contract.iapprovedby === 'Team Head') {
                return role === 'head';
            } else if (contract.iapprovedby === 'Any Team Member') {
                return true;
            } else if (contract.iapprovedby === 'Specific Team Member') {
                return contract.approved_email === email;
            }
            return false;
        });

        // Render contracts for Contract Modification tab
        modificationTbody.innerHTML = '';
        if (filteredModificationContracts.length > 0) {
            filteredModificationContracts.forEach(contract => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${contract.title}</td>
                    <td>${contract.requested_by}</td>
                    <td>${contract.accountname}</td>
                    <td>${new Date(contract.createdon).toLocaleString()}</td>
                    <td>${new Date(contract.updatedon).toLocaleString()}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary review-btn" 
                                data-id="${contract.id}"
                                data-cid="${contract.cid}" 
                                data-storage-path="${contract.new_storage_path}" 
                                data-title="${contract.title}">
                            Review
                        </button>
                    </td>
                `;
                modificationTbody.appendChild(row);

                row.querySelector('.review-btn').addEventListener('click', () => {
                    openModificationReviewDocument(
                        contract.id,
                        contract.cid,
                        contract.new_storage_path,
                        contract.title,
                        contractsTableName
                    );
                });
            });
        } else {
            modificationTbody.innerHTML = '<tr><td colspan="6" class="text-center">No contract modifications to review.</td></tr>';
        }

        if (isLegalOrFinancial && cancellationTbody) {
            // Fetch unique contracts by cid for Cancellation Initiated to Finance Team
            const { data: cancellationContracts, error: cancellationError } = await supabaseClient
                .from(contractsTableName)
                .select('id, cid, title, requested_by, accountname, createdon, updatedon, storage_path, iapprovedby, approved_email, requested_team')
                .eq('stage', 'Cancellation Initiated to Finance Team')
                .eq('status', 'Cancellation Initiated to Finance Team')
                .order('createdon', { ascending: false });

            if (cancellationError) {
                throw new Error(`Failed to fetch cancellation contracts: ${cancellationError.message}`);
            }

            // Filter contracts based on iapprovedby conditions and ensure unique cids
            const uniqueCids = new Set();
            const filteredCancellationContracts = cancellationContracts.filter(contract => {
                if (uniqueCids.has(contract.cid)) return false; // Skip if cid already processed
                uniqueCids.add(contract.cid);
                return true; // Include all contracts, no iapprovedby filtering
            });

            // Render filtered contracts for Contract Cancellation tab
            cancellationTbody.innerHTML = '';
            if (filteredCancellationContracts.length > 0) {
                filteredCancellationContracts.forEach(contract => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${contract.title}</td>
                        <td>${contract.requested_by}</td>
                        <td>${contract.accountname}</td>
                        <td>${new Date(contract.createdon).toLocaleString()}</td>
                        <td>${new Date(contract.updatedon).toLocaleString()}</td>
                        <td>
                            <button class="btn btn-sm btn-outline-danger initiate-cancellation-btn" 
                                    data-id="${contract.id}"
                                    data-cid="${contract.cid}" 
                                    data-storage-path="${contract.storage_path}" 
                                    data-title="${contract.title}">
                                Initiate Cancellation
                            </button>
                        </td>
                    `;
                    cancellationTbody.appendChild(row);

                    row.querySelector('.initiate-cancellation-btn').addEventListener('click', async () => {
                        // Fetch termination conditions from metadata table
                        const { data: metadata, error: metadataError } = await supabaseClient
                            .from(metadataTableName)
                            .select('terminationconditions')
                            .eq('cid', contract.cid)
                            .single();

                        if (metadataError) {
                            console.error('Error fetching termination conditions:', metadataError);
                            alert('Failed to fetch termination conditions.');
                            return;
                        }

                        // Create cancellation popup
                        const popup = document.createElement('div');
                        popup.className = 'modal fade show';
                        popup.style.display = 'block';
                        popup.innerHTML = `
                            <div class="modal-dialog">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title">Initiate Cancellation: ${contract.title}</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body">
                                        <div class="mb-3">
                                            <label class="form-label"><strong>Cancellation Terms</strong></label>
                                            <p>${metadata.terminationconditions || 'No termination conditions specified.'}</p>
                                        </div>
                                        <div class="mb-3">
                                            <label for="cancellationRemarks" class="form-label">Remarks</label>
                                            <textarea class="form-control" id="cancellationRemarks" rows="4" placeholder="Enter your remarks"></textarea>
                                        </div>
                                    </div>
                                    <div class="modal-footer">
                                        <button type="button" class="btn btn-secondary" id="historyBtn">History</button>
                                        <button type="button" class="btn btn-primary" id="submitCancellationBtn">Submit</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        document.body.appendChild(popup);

                        // Close cancellation popup
                        popup.querySelector('.btn-close').addEventListener('click', () => {
                            popup.remove();
                        });

                        // History button: Open history popup
                        popup.querySelector('#historyBtn').addEventListener('click', async () => {
                            try {
                                // Fetch cancellation history
                                const { data: historyData, error: historyError } = await supabaseClient
                                    .from(cancellationTableName)
                                    .select('initiator_name, initiator_team, remark')
                                    .eq('cid', contract.cid);

                                if (historyError) {
                                    throw new Error(`Failed to fetch cancellation history: ${historyError.message}`);
                                }

                                // Create history popup
                                const historyPopup = document.createElement('div');
                                historyPopup.className = 'modal fade show';
                                historyPopup.style.display = 'block';
                                historyPopup.innerHTML = `
                                    <div class="modal-dialog">
                                        <div class="modal-content">
                                            <div class="modal-header">
                                                <h5 class="modal-title">Cancellation History: ${contract.title}</h5>
                                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                            </div>
                                            <div class="modal-body">
                                                <table class="table table-bordered">
                                                    <thead>
                                                        <tr>
                                                            <th>Initiator Name</th>
                                                            <th>Initiator Team</th>
                                                            <th>Remarks</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody id="historyTableBody">
                                                        ${historyData && historyData.length > 0
                                                            ? historyData.map(row => `
                                                                <tr>
                                                                    <td>${row.initiator_name || 'N/A'}</td>
                                                                    <td>${row.initiator_team || 'N/A'}</td>
                                                                    <td>${row.remark || 'No remarks'}</td>
                                                                </tr>
                                                            `).join('')
                                                            : '<tr><td colspan="3" class="text-center">No history found.</td></tr>'
                                                        }
                                                    </tbody>
                                                </table>
                                            </div>
                                            <div class="modal-footer">
                                                <button type="button" class="btn btn-secondary" id="closeHistoryBtn">Close</button>
                                            </div>
                                        </div>
                                    </div>
                                `;
                                document.body.appendChild(historyPopup);

                                // Close history popup
                                historyPopup.querySelector('#closeHistoryBtn').addEventListener('click', () => {
                                    historyPopup.remove();
                                });
                                historyPopup.querySelector('.btn-close').addEventListener('click', () => {
                                    historyPopup.remove();
                                });
                            } catch (err) {
                                console.error('Error loading cancellation history:', err);
                                alert(`Error: ${err.message}`);
                            }
                        });

                        // Submit cancellation
                        popup.querySelector('#submitCancellationBtn').addEventListener('click', async () => {
                            const remarks = popup.querySelector('#cancellationRemarks').value.trim();
                            if (!remarks) {
                                alert('Please provide remarks for cancellation.');
                                return;
                            }

                            try {
                                // Fetch contract details (title, requested_by, requested_team)
                                const { data: contractData, error: contractError } = await supabaseClient
                                    .from(contractsTableName)
                                    .select('title, requested_by, requested_team')
                                    .eq('cid', contract.cid)
                                    .limit(1)
                                    .single();

                                if (contractError) {
                                    throw new Error(`Failed to fetch contract details: ${contractError.message}`);
                                }

                                // Fetch initiator details from users table
                                const loggedInUsername = localStorage.getItem('loggedInAdminUsername');
                                if (!loggedInUsername) {
                                    throw new Error('No logged-in user found in localStorage');
                                }

                                const { data: userData, error: userError } = await supabaseClient
                                    .from('users')
                                    .select('name, team_type')
                                    .eq('username', loggedInUsername)
                                    .single();

                                if (userError) {
                                    throw new Error(`Failed to fetch user details: ${userError.message}`);
                                }

                                // Update all rows with matching cid
                                const { error: updateError } = await supabaseClient
                                    .from(contractsTableName)
                                    .update({
                                        stage: 'Cancellation Initiated to Legal Team',
                                        status: 'Cancellation Initiated to Legal Team',
                                        updatedon: new Date().toISOString()
                                    })
                                    .eq('cid', contract.cid);

                                if (updateError) {
                                    throw new Error(`Failed to update contract status: ${updateError.message}`);
                                }

                                // Insert into cancellation table
                                const { error: insertError } = await supabaseClient
                                    .from(cancellationTableName)
                                    .insert({
                                        cid: contract.cid,
                                        contracttitle: contractData.title,
                                        requested_by: contractData.requested_by,
                                        requested_team: contractData.requested_team,
                                        initiator_name: userData.name,
                                        initiator_team: userData.team_type,
                                        remark: remarks,
                                        subject: null,
                                        body: null,
                                        storage_path: null,
                                        timestamp: new Date().toISOString()
                                    });

                                if (insertError) {
                                    throw new Error(`Failed to insert cancellation record: ${insertError.message}`);
                                }

                                alert('Cancellation initiated successfully.');
                                popup.remove();
                                // Refresh the table
                                await populateReviewersTable(organisationName, teamType, role, email, isLegalOrFinancial);
                            } catch (err) {
                                console.error('Error initiating cancellation:', err);
                                alert(`Error: ${err.message}`);
                            }
                        });
                    });
                });
            } else {
                cancellationTbody.innerHTML = '<tr><td colspan="6" class="text-center">No contracts pending cancellation initiation.</td></tr>';
            }
        }
    } catch (err) {
        console.error('Error populating reviewers table:', err);
        creationTbody.innerHTML = `<tr><td colspan="6" class="text-center">Error: ${err.message}</td></tr>`;
        if (isLegalOrFinancial && cancellationTbody) {
            cancellationTbody.innerHTML = `<tr><td colspan="6" class="text-center">Error: ${err.message}</td></tr>`;
        }
    }
}
async function openModificationReviewDocument(id, cid, storagePath, title, contractsTableName) {
    const editorContainer = document.getElementById('fullScreenEditor');
    const templatesContent = document.getElementById('templatesContent');
    const editorButtons = document.getElementById('editorButtons') || document.createElement('div'); // Fallback if editorButtons doesn't exist
    editorButtons.id = 'editorButtons';

    templatesContent.classList.add('hidden');
    editorContainer.style.display = 'block';

    const baseUrl = 'http://192.168.4.37:3000';
    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
    const fileUrl = `${baseUrl}${storagePath}`;
    const username = localStorage.getItem('loggedInAdminUsername');

    const config = {
        document: {
            fileType: 'docx',
            title: `${title}.docx`,
            url: fileUrl,
            key: `${cid}_${Date.now()}`,
            permissions: { edit: false, download: false } // Read-only mode
        },
        documentType: 'word',
        editorConfig: {
            mode: 'view', // View mode for read-only
            user: { id: username, name: username },
            lang: 'en'
        },
        height: '100%',
        width: '100%'
    };
    const token = jwt.sign(config, jwtSecret);
    config.token = token;

    // Destroy existing editor if it exists
    if (createEditor) createEditor.destroyEditor();

    // Add buttons for OK to Proceed, Add Comment, and Close
    editorButtons.innerHTML = `
        <button id="okToProceedBtn" class="btn btn-success">OK to Proceed</button>
        <button id="addCommentBtn" class="btn btn-info">Add Comment</button>
        <button id="closeReviewBtn" class="btn btn-secondary">Close</button>
    `;
    editorContainer.innerHTML = '<div id="editorWrapper" style="height: 80vh;"></div>';
    editorContainer.prepend(editorButtons);

    // Initialize OnlyOffice editor
    createEditor = new DocsAPI.DocEditor('editorWrapper', config);

    // OK to Proceed button
    document.getElementById('okToProceedBtn').onclick = async () => {
        try {
            const { error } = await supabaseClient
                .from(contractsTableName)
                .update({ valid: 'Done', updatedon: new Date().toISOString() })
                .eq('id', id)
                .eq('valid', 'Pending');
            if (error) throw new Error(`Failed to approve: ${error.message}`);
            alert('Contract modification approved successfully!');
            createEditor.destroyEditor();
            editorContainer.style.display = 'none';
            templatesContent.classList.remove('hidden');
            showReviewers(document.getElementById('reviewersLink'));
        } catch (err) {
            console.error('Error approving contract modification:', err);
            alert(`Error: ${err.message}`);
        }
    };

    // Add Comment button
    document.getElementById('addCommentBtn').onclick = () => {
        openCommentedModal(id, cid, contractsTableName);
    };

    // Close button
    document.getElementById('closeReviewBtn').onclick = () => {
        createEditor.destroyEditor();
        editorContainer.style.display = 'none';
        templatesContent.classList.remove('hidden');
        showReviewers(document.getElementById('reviewersLink'));
    };
}

// Reused openCommentModal function (assumed to be defined elsewhere or added here)
function openCommentedModal(id, cid, contractsTableName) {
    const commentPopup = document.createElement('div');
    commentPopup.className = 'modal fade show';
    commentPopup.style.display = 'block';
    commentPopup.innerHTML = `
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Add Comment</h5>
                    <button type="button" class="btn-close" onclick="this.closest('.modal').remove()"></button>
                </div>
                <div class="modal-body">
                    <textarea id="commentText" class="form-control" rows="4" placeholder="Enter your comment"></textarea>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="this.closest('.modal').remove()">Cancel</button>
                    <button type="button" id="submitCommentBtn" class="btn btn-primary">Submit</button>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(commentPopup);

    // Handle comment submission
    document.getElementById('submitCommentBtn').onclick = async () => {
        const comment = document.getElementById('commentText').value.trim();
        if (!comment) {
            alert('Please enter a comment.');
            return;
        }

        try {
            // Update all rows with the same cid to stage: 'Draft', status: 'In Progress', valid: 'Pending'
            const { error } = await supabaseClient
                .from(contractsTableName)
                .update({
                    stage: 'Draft',
                    status: 'In Progress',
                    valid: 'Pending',
                    updatedon: new Date().toISOString()
                })
                .eq('cid', cid);
            if (error) throw new Error(`Failed to update contract: ${error.message}`);

            // Optionally, store the comment (assuming a comments column or table exists)
            // Example: await supabaseClient.from('comments').insert({ contract_id: id, comment, created_by: localStorage.getItem('loggedInAdminUsername') });

            alert('Comment submitted successfully.');
            commentPopup.remove();
            createEditor.destroyEditor();
            document.getElementById('fullScreenEditor').style.display = 'none';
            document.getElementById('templatesContent').classList.remove('hidden');
            showReviewers(document.getElementById('reviewersLink'));
        } catch (err) {
            console.error('Error submitting comment:', err);
            alert(`Error: ${err.message}`);
        }
    };
}
async function openReviewDocument(id, cid, storagePath, title, contractsTableName) {
    const editorContainer = document.getElementById('fullScreenEditor');
    const templatesContent = document.getElementById('templatesContent');
    const editorButtons = document.getElementById('editorButtons');

    templatesContent.classList.add('hidden');
    editorContainer.style.display = 'block';

    const baseUrl = 'http://192.168.4.37:3000';
    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
    const fileUrl = `${baseUrl}${storagePath}`;
    const username = localStorage.getItem('loggedInAdminUsername');

    const config = {
        document: {
            fileType: 'docx',
            title: `${title}.docx`,
            url: fileUrl,
            key: `${cid}_${Date.now()}`,
            permissions: { edit: false, download: false } // Read-only mode
        },
        documentType: 'word',
        editorConfig: {
            mode: 'view', // View mode for read-only
            user: { id: username, name: username },
            lang: 'en'
        },
        height: '100%',
        width: '100%'
    };
    const token = jwt.sign(config, jwtSecret);
    config.token = token;

    if (createEditor) createEditor.destroyEditor();

    editorButtons.innerHTML = `
        <button id="okToProceedBtn" class="btn btn-success">OK to Proceed</button>
        <button id="addCommentBtn" class="btn btn-info">Add Comment</button>
        <button id="closeReviewBtn" class="btn btn-secondary">Close</button>
    `;

    createEditor = new DocsAPI.DocEditor('editorWrapper', config);

    // OK to Proceed button
    document.getElementById('okToProceedBtn').onclick = async () => {
        try {
            const { error } = await supabaseClient
                .from(contractsTableName)
                .update({ valid: 'Done', updatedon: new Date().toISOString() })
                .eq('id', id)
                .eq('valid', 'Pending');
            if (error) throw new Error(`Failed to approve: ${error.message}`);
            alert('Contract approved successfully!');
            createEditor.destroyEditor();
            editorContainer.style.display = 'none';
            templatesContent.classList.remove('hidden');
            showReviewers(document.getElementById('reviewersLink'));
        } catch (err) {
            console.error('Error approving contract:', err);
            alert(`Error: ${err.message}`);
        }
    };

    // Add Comment button
    document.getElementById('addCommentBtn').onclick = () => {
        openCommentModal(id, cid, contractsTableName);
    };

    // Close button
    document.getElementById('closeReviewBtn').onclick = () => {
        createEditor.destroyEditor();
        editorContainer.style.display = 'none';
        templatesContent.classList.remove('hidden');
        showReviewers(document.getElementById('reviewersLink'));
    };
}

async function openCommentModal(id, cid, contractsTableName) {
    const modalHtml = `
        <div class="modal fade" id="addCommentModal" tabindex="-1" aria-labelledby="addCommentModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="addCommentModalLabel">Add Comment</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="commentText" class="form-label">Comment</label>
                            <textarea class="form-control" id="commentText" rows="4" placeholder="Enter your comment" required></textarea>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="submitCommentBtn">Submit</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const modal = new bootstrap.Modal(document.getElementById('addCommentModal'));
    modal.show();

    document.getElementById('submitCommentBtn').onclick = async () => {
        const comment = document.getElementById('commentText').value.trim();
        if (!comment) {
            alert('Please enter a comment.');
            return;
        }

        try {
            // Update all rows with the same cid to Draft/In Progress/Pending
            const { error: updateError } = await supabaseClient
                .from(contractsTableName)
                .update({
                    stage: 'Draft',
                    status: 'In Progress',
                    valid: 'Pending',
                    updatedon: new Date().toISOString()
                })
                .eq('cid', cid);
            if (updateError) throw new Error(`Failed to update contract: ${updateError.message}`);

            alert('Comment submitted successfully! Contract reverted to Draft.');
            modal.hide();
            if (createEditor) createEditor.destroyEditor();
            document.getElementById('fullScreenEditor').style.display = 'none';
            document.getElementById('templatesContent').classList.remove('hidden');
            showReviewers(document.getElementById('reviewersLink'));
        } catch (err) {
            console.error('Error submitting comment:', err);
            alert(`Error: ${err.message}`);
        }
    };

    document.getElementById('addCommentModal').addEventListener('hidden.bs.modal', () => {
        document.getElementById('addCommentModal').remove();
    });
}
// Show Signatures
async function showSignatures(element) {
    const menuItems = document.querySelectorAll('.menu-item');
    menuItems.forEach(item => item.classList.remove('active'));
    element.parentElement.classList.add('active');
    const myApprovalsMenu = document.getElementById('myApprovalsLink').parentElement;
    myApprovalsMenu.classList.add('active');
    const submenu = myApprovalsMenu.querySelector('.menu-sub');
    submenu.style.display = 'block';

    const templatesContent = document.getElementById('templatesContent');
    const editorContainer = document.getElementById('fullScreenEditor');

    if (!editorContainer) {
        console.error('fullScreenEditor element not found in DOM');
        templatesContent.innerHTML = `<div class="card"><div class="card-body">Error: Editor container not found</div></div>`;
        return;
    }
    editorContainer.style.display = 'none';
    templatesContent.classList.remove('hidden');

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    const loggedInUsername = localStorage.getItem('loggedInAdminUsername');
    if (!organisationName || !loggedInUsername) {
        alert('No user logged in. Please log in first.');
        window.location.href = 'login.html';
        return;
    }

    templatesContent.innerHTML = `
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Signatures</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-bordered table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>Agreement Title</th>
                                <th>Requested By</th>
                                <th>Account Name</th>
                                <th>Created On</th>
                                <th>Updated On</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="signaturesTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    `;

    const contractsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;

    try {
        // Fetch user details
        const { data: userData, error: userError } = await supabaseClient
            .from('users')
            .select('team_type, role, email, organisation')
            .eq('username', loggedInUsername)
            .eq('organisation', organisationName)
            .single();
        if (userError || !userData) {
            throw new Error(`Failed to fetch user details: ${userError?.message || 'No user found'}`);
        }
        const { team_type, role, email } = userData;

        // Fetch contracts with initial filters
        const { data: contracts, error: contractsError } = await supabaseClient
            .from(contractsTableName)
            .select('id, cid, title, requested_by, accountname, createdon, updatedon, storage_path_pdf, isignedby, signed_email, team, valid')
            .eq('stage', 'Pending Signature – Internal')
            .eq('status', 'In Progress')
            .eq('valid', 'Pending')
            .eq('team', team_type);
        if (contractsError) {
            throw new Error(`Failed to fetch contracts: ${contractsError.message}`);
        }

        // Filter based on isignedby conditions
        const filteredContracts = contracts.filter(contract => {
            if (contract.team !== team_type) return false;
            if (contract.isignedby === 'Team Head') {
                return role === 'head';
            } else if (contract.isignedby === 'Any Team Member') {
                return true;
            } else if (contract.isignedby === 'Specific Team Member') {
                return contract.signed_email === email;
            }
            return false;
        });

        // Render filtered contracts
        const tbody = document.getElementById('signaturesTableBody');
        tbody.innerHTML = '';
        if (filteredContracts.length > 0) {
            filteredContracts.forEach(contract => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${contract.title}</td>
                    <td>${contract.requested_by}</td>
                    <td>${contract.accountname}</td>
                    <td>${new Date(contract.createdon).toLocaleString()}</td>
                    <td>${new Date(contract.updatedon).toLocaleString()}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary review-btn" 
                                data-id="${contract.id}" 
                                data-cid="${contract.cid}" 
                                data-storage-path="${contract.storage_path_pdf}" 
                                data-title="${contract.title}">
                            Review
                        </button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            // Attach event listeners to review buttons
            document.querySelectorAll('.review-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const id = btn.dataset.id;
                    const cid = btn.dataset.cid;
                    const storagePath = btn.dataset.storagePath;
                    const title = btn.dataset.title;
                    openSignatureDocument(id, cid, storagePath, title, contractsTableName, email, team_type);
                });
            });
        } else {
            tbody.innerHTML = '<tr><td colspan="6" class="text-center">No signatures pending.</td></tr>';
        }
    } catch (err) {
        console.error('Error in showSignatures:', err);
        const tbody = document.getElementById('signaturesTableBody');
        tbody.innerHTML = `<tr><td colspan="6" class="text-center">Error: ${err.message}</td></tr>`;
    }
}
async function openSignatureDocument(id, cid, storagePath, title, contractsTableName, userEmail, team_type) {
    const editorContainer = document.getElementById('fullScreenEditor');
    const templatesContent = document.getElementById('templatesContent');
    const editorButtons = document.getElementById('editorButtons');

    templatesContent.classList.add('hidden');
    editorContainer.style.display = 'block';

    const baseUrl = 'http://192.168.4.37:3000';
    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
    const fileUrl = `${baseUrl}${storagePath}`;
    const callbackUrl = `${baseUrl}/sync-draft?tableName=${contractsTableName}&contractId=${cid}&contractTitle=${encodeURIComponent(title)}&orgcode=${storagePath.split('/')[1]}&username=${encodeURIComponent(localStorage.getItem('loggedInAdminUsername'))}`;

    const config = {
        document: {
            fileType: 'pdf',
            title: `${title}.pdf`,
            url: fileUrl,
            key: `${cid}_${Date.now()}`,
            permissions: { edit: true, download: true }
        },
        documentType: 'pdf',
        editorConfig: {
            mode: 'edit',
            callbackUrl: callbackUrl,
            user: { id: localStorage.getItem('loggedInAdminUsername'), name: localStorage.getItem('loggedInAdminUsername') },
            lang: 'en'
        },
        events: {
            onReady: () => console.log('Editor is ready'),
            onError: (event) => console.error('Editor error:', event.data),
            onDocumentStateChange: (event) => {
                if (event.data && event.data.saved) {
                    console.log('Document changes saved');
                }
            }
        },
        height: '100%',
        width: '100%'
    };
    const token = jwt.sign(config, jwtSecret);
    config.token = token;

    if (createEditor) createEditor.destroyEditor();

    editorButtons.innerHTML = `
        <button id="initiateSignatureBtn" class="btn btn-success">Initiate Signature</button>
        <button id="addCommentBtn" class="btn btn-info">Add Comment</button>
        <button id="closeEditorBtn" class="btn btn-secondary">Close</button>
    `;

    createEditor = new DocsAPI.DocEditor('editorWrapper', config);

    document.getElementById('initiateSignatureBtn').onclick = () => showSignatureOptions(id, cid, storagePath, title, contractsTableName, userEmail, team_type);
    document.getElementById('addCommentBtn').onclick = () => showCommentPopup(id, cid, contractsTableName);
    document.getElementById('closeEditorBtn').onclick = () => {
        if (createEditor) createEditor.destroyEditor();
        editorContainer.style.display = 'none';
        templatesContent.classList.remove('hidden');
        showSignatures(element);
    };
}

function showSignatureOptions(id, cid, storagePath, title, contractsTableName, userEmail, team_type) {
    const modalHtml = `
        <div class="modal fade" id="signatureOptionsModal" tabindex="-1" aria-labelledby="signatureOptionsModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="signatureOptionsModalLabel">Initiate Signature</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="signatureMethod" id="autoGen" value="auto">
                            <label class="form-check-label" for="autoGen">Automatic Generation</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="signatureMethod" id="scratchPad" value="scratch">
                            <label class="form-check-label" for="scratchPad">Scratch Pad</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="signatureMethod" id="uploadImage" value="upload">
                            <label class="form-check-label" for="uploadImage">Upload Image</label>
                        </div>
                        <div id="autoGenBox" class="mt-3" style="display: none;">
                            <input type="text" class="form-control" id="signatureText" placeholder="Enter signature text">
                        </div>
                        <div id="scratchPadBox" class="mt-3" style="display: none;">
                            <canvas id="signatureCanvas" width="300" height="100" style="border: 1px solid #000;"></canvas>
                        </div>
                        <div id="uploadImageBox" class="mt-3" style="display: none;">
                            <input type="file" class="form-control" id="signatureImage" accept="image/*">
                        </div>
                        <div id="signaturePlacement" style="display: none; margin-top: 20px;">
                            <canvas id="placementCanvas"></canvas>
                            <button id="prevPage">Previous</button>
                            <button id="nextPage">Next</button>
                            <button id="confirmPlacement">OK</button>
                            <button id="cancelPlacement">Cancel</button>
                        </div>
                        <div id="previewContainer" style="display: none; margin-top: 20px;">
                            <h6>Preview of Signed PDF:</h6>
                            <iframe id="pdfPreview" style="width: 100%; height: 400px; border: 1px solid #ccc;"></iframe>
                            <button type="button" class="btn btn-primary mt-3" id="finalOkBtn">OK</button>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="confirmSignatureBtn">OK</button>
                    </div>
                </div>
            </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const modal = new bootstrap.Modal(document.getElementById('signatureOptionsModal'));
    modal.show();

    document.getElementById('autoGen').addEventListener('change', () => {
        document.getElementById('autoGenBox').style.display = 'block';
        document.getElementById('scratchPadBox').style.display = 'none';
        document.getElementById('uploadImageBox').style.display = 'none';
        document.getElementById('signaturePlacement').style.display = 'none';
    });
    document.getElementById('scratchPad').addEventListener('change', () => {
        document.getElementById('autoGenBox').style.display = 'none';
        document.getElementById('scratchPadBox').style.display = 'block';
        document.getElementById('uploadImageBox').style.display = 'none';
        document.getElementById('signaturePlacement').style.display = 'none';
        initSignatureCanvas();
    });
    document.getElementById('uploadImage').addEventListener('change', () => {
        document.getElementById('autoGenBox').style.display = 'none';
        document.getElementById('scratchPadBox').style.display = 'none';
        document.getElementById('uploadImageBox').style.display = 'block';
        document.getElementById('signaturePlacement').style.display = 'none';
    });

    document.getElementById('confirmSignatureBtn').onclick = async () => {
        const method = document.querySelector('input[name="signatureMethod"]:checked')?.value;
        let signatureData = null;

        if (method === 'auto') {
            const text = document.getElementById('signatureText').value;
            if (text) {
                const canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.font = '20px Arial';
                ctx.fillText(text, 10, 30);
                signatureData = canvas.toDataURL('image/png');
            }
        } else if (method === 'scratch') {
            const canvas = document.getElementById('signatureCanvas');
            signatureData = canvas.toDataURL('image/png');
        } else if (method === 'upload') {
            const fileInput = document.getElementById('signatureImage');
            if (fileInput.files.length > 0) {
                signatureData = fileInput.files[0];
            }
        }

        if (signatureData) {
            try {
                console.log('Starting signature placement with method:', method, 'signatureData type:', typeof signatureData);
                // Hide OK and Cancel buttons before placement begins
                const modalFooter = document.querySelector('#signatureOptionsModal .modal-footer');
                const okButton = document.getElementById('confirmSignatureBtn');
                const cancelButton = modalFooter.querySelector('.btn-secondary[data-bs-dismiss="modal"]');
                if (okButton && cancelButton) {
                    okButton.style.display = 'none';
                    cancelButton.style.display = 'none';
                }
                document.getElementById('signaturePlacement').style.display = 'block';
                const previewUrl = await placeSignature(id, cid, storagePath, title, contractsTableName, userEmail, signatureData);
                console.log('Received preview URL from placeSignature:', previewUrl);

                const previewContainer = document.getElementById('previewContainer');
                const pdfPreview = document.getElementById('pdfPreview');
                if (previewContainer && pdfPreview) {
                    console.log('Setting up preview with URL:', previewUrl);
                    previewContainer.style.display = 'block';
                    pdfPreview.src = previewUrl;
                    pdfPreview.onload = () => console.log('Iframe loaded successfully with URL:', previewUrl);
                    pdfPreview.onerror = (e) => console.error('Iframe load error:', e, 'URL:', previewUrl);
                } else {
                    console.error('Preview container or pdfPreview element not found in DOM');
                }
                alert('Signature added successfully! Preview below. The PDF has been overwritten.');
                // Add event listener for the final OK button
                document.getElementById('finalOkBtn').onclick = () => {
                    const modal = bootstrap.Modal.getInstance(document.getElementById('signatureOptionsModal'));
                    modal.hide();
                    setTimeout(() => {
                        window.location.href = '#signatures';
                        window.location.reload();
                    }, 1000); // 1-second delay
                };
            } catch (error) {
                console.error('Signature placement error:', error.message, error.stack);
                alert('Failed to add signature: ' + error.message);
            }
        } else {
            alert('No signature data provided.');
        }
        // modal.hide(); // Keep commented to leave modal open for preview
        // document.getElementById('signatureOptionsModal').remove(); // Keep commented
    };
}
function initSignatureCanvas() {
    const canvas = document.getElementById('signatureCanvas');
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    canvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        [lastX, lastY] = [e.offsetX, e.offsetY];
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDrawing) {
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDrawing = false;
    });

    canvas.addEventListener('mouseout', () => {
        isDrawing = false;
    });
}
function showCommentPopup(id, cid, contractsTableName) {
    const modalHtml = `
        <div class="modal fade" id="commentModal" tabindex="-1" aria-labelledby="commentModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="commentModalLabel">Add Comment</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <textarea class="form-control" id="commentText" rows="3" placeholder="Enter your comment"></textarea>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="submitCommentBtn">Submit</button>
                    </div>
                </div>
            </div>
        `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const modal = new bootstrap.Modal(document.getElementById('commentModal'));
    modal.show();

    document.getElementById('submitCommentBtn').onclick = async () => {
        const comment = document.getElementById('commentText').value.trim();
        if (comment) {
            const { error } = await supabaseClient
                .from(contractsTableName)
                .update({
                    stage: 'Draft',
                    status: 'In Progress',
                    valid: 'Pending',
                    updatedon: new Date().toISOString()
                })
                .eq('cid', cid);
            if (error) throw error;

            const { data, error: updateError } = await supabaseClient
                .from(contractsTableName)
                .update({ updatedon: new Date().toISOString() })
                .eq('cid', cid);
            if (updateError) throw updateError;

            modal.hide();
            document.getElementById('commentModal').remove();
            showSignatures(document.getElementById('signaturesLink'));
        }
    };
}

const { PDFDocument, rgb } = PDFLib;




async function placeSignature(id, cid, storagePath, title, contractsTableName, userEmail, signatureData) {
    console.log('Starting placeSignature with storagePath:', storagePath, 'userEmail:', userEmail, 'signatureData type:', typeof signatureData);

    // Fetch the PDF
    const pdfUrl = `http://192.168.4.37:3000/files${storagePath}`;
    console.log('Attempting to fetch PDF from:', pdfUrl);
    const response = await fetch(pdfUrl);
    if (!response.ok) {
        console.error('Fetch failed:', response.status, response.statusText);
        throw new Error(`Failed to fetch PDF: ${response.statusText}`);
    }
    const pdfBytes = await response.arrayBuffer();
    const pdfDoc = await PDFDocument.load(pdfBytes);

    // Try to extract form fields or annotations
    const form = pdfDoc.getForm();
    const fields = form ? form.getFields() : [];
    let signatureField = null;
    console.log('Extracted fields:', fields.map(f => ({ name: f.getName(), type: f.getType() })));

    for (const field of fields) {
        if (field instanceof pdfDoc.getForm().SignatureField) {
            const widget = field.widgets[0];
            const rect = widget.getRectangle();
            const fieldName = field.getName();
            console.log('Signature field found:', fieldName, 'at', rect);
            if (fieldName.toLowerCase().includes(userEmail.toLowerCase())) {
                signatureField = { left: rect.x, top: rect.y + rect.height, width: rect.width, height: rect.height };
                break;
            }
        }
    }

    // If no matching field, convert to images for manual selection using pdf.js
    let currentPageIndex = 0;
    let signaturePlaced = false;
    if (!signatureField) {
        console.log('No matching signature field found, converting to images for manual selection');
        const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(currentPageIndex + 1);
        const viewport = page.getViewport({ scale: 1.5 });
        const canvas = document.getElementById('placementCanvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');
        const renderContext = { canvasContext: ctx, viewport: viewport };
        await page.render(renderContext).promise;
        const canvasCenterY = canvas.height / 2;
        console.log('Canvas dimensions:', { width: canvas.width, height: canvas.height }, 'Center Y:', canvasCenterY);

        // Navigation and selection logic
        document.getElementById('prevPage').onclick = async () => {
            if (currentPageIndex > 0) {
                currentPageIndex--;
                await renderPage(pdf, currentPageIndex + 1);
            }
        };
        document.getElementById('nextPage').onclick = async () => {
            if (currentPageIndex < pdf.numPages - 1) {
                currentPageIndex++;
                await renderPage(pdf, currentPageIndex + 1);
            }
        };

        // Wait for user selection and confirmation
        try {
            signatureField = await new Promise((resolve, reject) => {
                let selectedX = 0, selectedY = 0;
                const canvas = document.getElementById('placementCanvas');
                const ctx = canvas.getContext('2d');

                canvas.addEventListener('click', (event) => {
                    const rect = canvas.getBoundingClientRect();
                    selectedX = event.clientX - rect.left;
                    selectedY = event.clientY - rect.top; // Top-down y coordinate
                    console.log('Raw click coordinates (top-down):', { x: selectedX, y: selectedY }, 'Relative to center:', selectedY - canvasCenterY);
                    ctx.beginPath();
                    ctx.rect(selectedX - 75, selectedY, 150, 50); // Box at click location
                    ctx.strokeStyle = 'blue';
                    ctx.stroke();
                });

                document.getElementById('confirmPlacement').onclick = () => {
                    if (selectedX && selectedY) {
                        const field = { left: selectedX - 75, top: selectedY, width: 150, height: 50 };
                        console.log('Confirmed signature placement at:', field);
                        document.getElementById('signaturePlacement').style.display = 'none';
                        resolve(field);
                    } else {
                        reject(new Error('No click position selected'));
                    }
                };

                document.getElementById('cancelPlacement').onclick = () => {
                    document.getElementById('signaturePlacement').style.display = 'none';
                    reject(new Error('Signature placement cancelled by user'));
                };

                // Set a timeout to reject if no action is taken
                setTimeout(() => reject(new Error('Signature placement timed out')), 30000); // 30-second timeout
            });

            const page = pdfDoc.getPages()[currentPageIndex];
            const pdfViewport = page.getSize();
            console.log('PDF page size:', pdfViewport);
            let pngData;
            if (typeof signatureData === 'string' && signatureData.startsWith('data:image/')) {
                const [mimeType] = signatureData.match(/data:image\/(png|jpeg|jpg)/i) || [];
                if (!mimeType) {
                    throw new Error('Unsupported image format. Only PNG and JPEG are supported.');
                }
                const base64String = signatureData.replace(/^data:image\/(png|jpeg|jpg);base64,/, '');
                pngData = Uint8Array.from(atob(base64String), c => c.charCodeAt(0));
                console.log('Extracted MIME type from base64:', mimeType);
            } else if (signatureData instanceof Blob) {
                // Validate file type
                if (!signatureData.type.startsWith('image/')) {
                    throw new Error('Unsupported file type. Please upload a PNG or JPEG image.');
                }
                const fileReader = new FileReader();
                pngData = await new Promise((resolve, reject) => {
                    fileReader.onload = (event) => resolve(new Uint8Array(event.target.result));
                    fileReader.onerror = () => reject(new Error('Failed to read uploaded image'));
                    fileReader.readAsArrayBuffer(signatureData);
                });
                console.log('Converted Blob to Uint8Array, length:', pngData.length, 'MIME type:', signatureData.type);
            } else {
                // Auto-generate signature if not a pre-existing image
                const canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.font = 'italic 20px Arial'; // Italic styling for signature-like text
                const text = userEmail.split('@')[0] || 'Signature'; // Use email username or default
                const textMetrics = ctx.measureText(text);
                const textX = (canvas.width - textMetrics.width) / 2;
                const textY = (canvas.height + 20) / 2; // Center vertically with font size adjustment
                ctx.fillText(text, textX, textY);
                pngData = Uint8Array.from(atob(canvas.toDataURL('image/png').split(',')[1]), c => c.charCodeAt(0));
                console.log('Auto-generated PNG signature with italic text');
            }
            let img;
            try {
                if (typeof signatureData === 'string' && /png/i.test(signatureData)) {
                    img = await pdfDoc.embedPng(pngData);
                    console.log('Embedded PNG successfully');
                } else if (typeof signatureData === 'string' && /jpeg|jpg/i.test(signatureData)) {
                    img = await pdfDoc.embedJpg(pngData);
                    console.log('Embedded JPG successfully');
                } else if (signatureData.type === 'image/png' || signatureData.type === 'image/x-png') {
                    img = await pdfDoc.embedPng(pngData);
                    console.log('Embedded PNG successfully');
                } else if (signatureData.type === 'image/jpeg' || signatureData.type === 'image/jpg') {
                    img = await pdfDoc.embedJpg(pngData);
                    console.log('Embedded JPG successfully');
                } else {
                    img = await pdfDoc.embedPng(pngData); // Default to PNG for auto-generated
                    console.log('Embedded auto-generated PNG successfully');
                }
            } catch (error) {
                console.error('Error embedding image:', error.message, error.stack);
                throw error;
            }
            // Adjust coordinates to match PDF bottom-up coordinates
            const scaleX = pdfViewport.width / canvas.width;
            const scaleY = pdfViewport.height / canvas.height;
            const adjustedX = signatureField.left * scaleX;
            const adjustedY = (pdfViewport.height - (signatureField.top * scaleY + signatureField.height * scaleY)); // Invert y for PDF
            console.log('Adjusted coordinates for PDF:', { x: adjustedX, y: adjustedY }, 'Box height:', signatureField.height * scaleY);
            try {
                page.drawImage(img, {
                    x: adjustedX,
                    y: adjustedY,
                    width: signatureField.width * scaleX,
                    height: signatureField.height * scaleY,
                    opacity: 1.0
                });
                console.log('Image drawn successfully');
            } catch (error) {
                console.error('Error drawing image:', error.message, error.stack);
                throw error;
            }
            signaturePlaced = true;
            console.log('Signature image embedded at adjusted coordinates:', adjustedX, adjustedY);
        } catch (error) {
            console.error('Manual selection error:', error.message, error.stack);
            throw error; // Propagate error to caller
        }
    }

    // Place signature if field was found or set
    if (signatureField && !signaturePlaced) {
        try {
            let pngData;
            if (typeof signatureData === 'string' && signatureData.startsWith('data:image/')) {
                const [mimeType] = signatureData.match(/data:image\/(png|jpeg|jpg)/i) || [];
                if (!mimeType) {
                    throw new Error('Unsupported image format. Only PNG and JPEG are supported.');
                }
                const base64String = signatureData.replace(/^data:image\/(png|jpeg|jpg);base64,/, '');
                pngData = Uint8Array.from(atob(base64String), c => c.charCodeAt(0));
                console.log('Extracted MIME type from base64:', mimeType);
            } else if (signatureData instanceof Blob) {
                if (!signatureData.type.startsWith('image/')) {
                    throw new Error('Unsupported file type. Please upload a PNG or JPEG image.');
                }
                const fileReader = new FileReader();
                pngData = await new Promise((resolve, reject) => {
                    fileReader.onload = (event) => resolve(new Uint8Array(event.target.result));
                    fileReader.onerror = () => reject(new Error('Failed to read uploaded image'));
                    fileReader.readAsArrayBuffer(signatureData);
                });
                console.log('Converted Blob to Uint8Array, length:', pngData.length, 'MIME type:', signatureData.type);
            } else {
                // Auto-generate signature if not a pre-existing image
                const canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.font = 'italic 20px Arial'; // Italic styling for signature-like text
                const text = userEmail.split('@')[0] || 'Signature'; // Use email username or default
                const textMetrics = ctx.measureText(text);
                const textX = (canvas.width - textMetrics.width) / 2;
                const textY = (canvas.height + 20) / 2; // Center vertically with font size adjustment
                ctx.fillText(text, textX, textY);
                pngData = Uint8Array.from(atob(canvas.toDataURL('image/png').split(',')[1]), c => c.charCodeAt(0));
                console.log('Auto-generated PNG signature with italic text');
            }
            let img;
            try {
                if (typeof signatureData === 'string' && /png/i.test(signatureData)) {
                    img = await pdfDoc.embedPng(pngData);
                    console.log('Embedded PNG successfully');
                } else if (typeof signatureData === 'string' && /jpeg|jpg/i.test(signatureData)) {
                    img = await pdfDoc.embedJpg(pngData);
                    console.log('Embedded JPG successfully');
                } else if (signatureData.type === 'image/png' || signatureData.type === 'image/x-png') {
                    img = await pdfDoc.embedPng(pngData);
                    console.log('Embedded PNG successfully');
                } else if (signatureData.type === 'image/jpeg' || signatureData.type === 'image/jpg') {
                    img = await pdfDoc.embedJpg(pngData);
                    console.log('Embedded JPG successfully');
                } else {
                    img = await pdfDoc.embedPng(pngData); // Default to PNG for auto-generated
                    console.log('Embedded auto-generated PNG successfully');
                }
            } catch (error) {
                console.error('Error embedding image:', error.message, error.stack);
                throw error;
            }
            page.drawImage(img, {
                x: signatureField.left,
                y: signatureField.top - signatureField.height,
                width: signatureField.width,
                height: signatureField.height,
                opacity: 1.0
            }).catch(error => {
                console.error('Error drawing image:', error.message, error.stack);
                throw error;
            });
            signaturePlaced = true;
            console.log('Signature image embedded at:', signatureField.left, signatureField.top - signatureField.height);
        } catch (error) {
            console.error('Signature placement error:', error.message, error.stack);
            throw error;
        }
    }

    if (!signaturePlaced) {
        throw new Error('No signature field selected or detected.');
    }

    const updatedPdfBytes = await pdfDoc.save();
    const blob = new Blob([updatedPdfBytes], { type: 'application/pdf' });

    // Overwrite the original file
    const saveUrl = `http://192.168.4.37:3000/upload`;
    const formData = new FormData();
    const filename = storagePath.split('/').pop() || `${title}.pdf`;
    console.log('Appending file with filename:', filename, 'and path:', storagePath);
    formData.append('file', blob, filename);
    formData.append('path', storagePath);
    console.log('FormData preview:', Array.from(formData.entries()).map(([key, value]) => `${key}: ${value instanceof Blob ? 'Blob' : value.toString().substring(0, 50)}`).join(', '));

    await new Promise(resolve => setTimeout(resolve, 15000)); // 15-second delay to ensure file update

    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 180000); // 3-minute timeout
        const saveResponse = await fetch(saveUrl, {
            method: 'POST',
            body: formData,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        console.log('Save response status:', saveResponse.status, 'statusText:', saveResponse.statusText);
        if (!saveResponse.ok) {
            const errorText = await saveResponse.text();
            console.error('Save response error:', saveResponse.status, saveResponse.statusText, 'URL:', saveUrl, 'Response text:', errorText);
            throw new Error(`Failed to save PDF: ${saveResponse.statusText} - ${errorText}`);
        }
        console.log('PDF overwritten successfully at:', saveUrl, 'with path:', storagePath);
    } catch (error) {
        console.error('Fetch error during save:', error.name, error.message, error.stack);
        throw error;
    }

    // Poll server to confirm file availability
    const maxAttempts = 5;
    let attempt = 0;
    let fileAvailable = false;
    while (attempt < maxAttempts && !fileAvailable) {
        try {
            const checkResponse = await fetch(pdfUrl, { method: 'HEAD' });
            console.log('File availability check attempt:', attempt + 1, 'Status:', checkResponse.status, 'Status Text:', checkResponse.statusText);
            if (checkResponse.ok) {
                fileAvailable = true;
                console.log('File confirmed available at:', pdfUrl);
            } else {
                console.log('File not yet available, attempt:', attempt + 1, 'Waiting 3 seconds...');
                await new Promise(resolve => setTimeout(resolve, 3000)); // 3-second interval
                attempt++;
            }
        } catch (error) {
            console.log('Check failed, attempt:', attempt + 1, 'Error:', error.name, error.message);
            await new Promise(resolve => setTimeout(resolve, 3000)); // 3-second interval
            attempt++;
        }
    }

    if (!fileAvailable) {
        console.warn('File not available after max attempts:', maxAttempts, 'Proceeding with potential delay.');
    }

    // Update database with original storage path
    const { error: dbError } = await supabaseClient
        .from(contractsTableName)
        .update({ valid: 'Done', updatedon: new Date().toISOString(), storage_path: storagePath })
        .eq('id', id);
    if (dbError) {
        console.error('Database update error:', dbError.message);
        throw dbError;
    }
    console.log('Database updated with storage_path:', storagePath);

    // Return preview URL
    const previewUrl = `${pdfUrl}?t=${Date.now()}`;
    console.log('Returning preview URL:', previewUrl);
    return previewUrl;

    // Function to render a specific page
    async function renderPage(pdfDoc, pageNum) {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 1.5 });
        const canvas = document.getElementById('placementCanvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');
        const renderContext = { canvasContext: ctx, viewport: viewport };
        await page.render(renderContext).promise;
    }
}
function showCommentPopup(id, cid, contractsTableName) {
    const modalHtml = `
        <div class="modal fade" id="commentModal" tabindex="-1" aria-labelledby="commentModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="commentModalLabel">Add Comment</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <textarea class="form-control" id="commentText" rows="3" placeholder="Enter your comment"></textarea>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="submitCommentBtn">Submit</button>
                    </div>
                </div>
            </div>
        `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const modal = new bootstrap.Modal(document.getElementById('commentModal'));
    modal.show();

    document.getElementById('submitCommentBtn').onclick = async () => {
        const comment = document.getElementById('commentText').value.trim();
        if (comment) {
            const { error } = await supabaseClient
                .from(contractsTableName)
                .update({
                    stage: 'Draft',
                    status: 'In Progress',
                    valid: 'Pending',
                    updatedon: new Date().toISOString()
                })
                .eq('cid', cid);
            if (error) throw error;

            const { data, error: updateError } = await supabaseClient
                .from(contractsTableName)
                .update({ updatedon: new Date().toISOString() })
                .eq('cid', cid);
            if (updateError) throw updateError;

            modal.hide();
            document.getElementById('commentModal').remove();
            showSignatures(document.getElementById('signaturesLink'));
        }
    };
}

// Populate Signatures Table
async function populateSignaturesTable(orgName) {
    const tbody = document.getElementById('signaturesTableBody');
    const contractsTableName = `${orgName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;
    const username = localStorage.getItem('loggedInAdminUsername');
    const { data: userData, error: userError } = await supabaseClient
        .from('users')
        .select('email')
        .eq('username', username)
        .single();
    if (userError || !userData) {
        tbody.innerHTML = `<tr><td colspan="5" class="text-center">Error: Unable to fetch user data</td></tr>`;
        return;
    }
    const userEmail = userData.email;

    try {
        const { data: signatures, error } = await supabaseClient
            .from(contractsTableName)
            .select('title, requested_by, accountname, createdon, updatedon, cid')
            .eq('work', 'signature')
            .in('isignedby', ['Team', 'Specific Team Member'])
            .eq('signed_email', userEmail)
            .eq('valid', 'Pending')
            .order('createdon', { ascending: false });

        if (error) throw new Error(`Failed to fetch signatures: ${error.message}`);

        tbody.innerHTML = '';
        if (signatures && signatures.length > 0) {
            signatures.forEach(signature => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${signature.title}</td>
                    <td>${signature.requested_by}</td>
                    <td>${signature.accountname}</td>
                    <td>${new Date(signature.createdon).toLocaleString()}</td>
                    <td>${new Date(signature.updatedon).toLocaleString()}</td>
                    <td><button class="btn btn-sm btn-outline-primary sign-btn" data-cid="${signature.cid}">Sign</button></td>
                `;
                tbody.appendChild(row);

                row.querySelector('.sign-btn').addEventListener('click', () => {
                    signContract(signature.cid, contractsTableName);
                });
            });
        } else {
            tbody.innerHTML = '<tr><td colspan="6" class="text-center">No pending signatures found.</td></tr>';
        }
    } catch (err) {
        console.error('Error fetching signatures:', err);
        tbody.innerHTML = `<tr><td colspan="6" class="text-center">Error: ${err.message}</td></tr>`;
    }
}
// Review Contract
async function reviewContract(cid, contractsTableName) {
    const { data: contractData, error } = await supabaseClient
        .from(contractsTableName)
        .select('storage_path, title')
        .eq('cid', cid)
        .eq('work', 'approval')
        .eq('valid', 'Pending')
        .single();
    if (error || !contractData) {
        alert('Error fetching contract details.');
        return;
    }

    const editorContainer = document.getElementById('fullScreenEditor');
    const templatesContent = document.getElementById('templatesContent');
    const editorButtons = document.getElementById('editorButtons');

    templatesContent.classList.add('hidden');
    editorContainer.style.display = 'block';

    const baseUrl = 'http://192.168.4.37:3000';
    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
    const fileUrl = `${baseUrl}${contractData.storage_path}`;
    const username = localStorage.getItem('loggedInAdminUsername');
    const orgcode = (await supabaseClient.from('orgadmins').select('org_code').eq('organisation_name', localStorage.getItem('loggedInOrganisationName')).single()).data.org_code;

    const config = {
        document: {
            fileType: 'docx',
            title: `${contractData.title}.docx`,
            url: fileUrl,
            key: `${cid}_${Date.now()}`,
            permissions: { edit: false, download: true }
        },
        documentType: 'word',
        editorConfig: {
            mode: 'view',
            user: { id: username, name: username },
            lang: 'en'
        },
        height: '100%',
        width: '100%'
    };
    const token = jwt.sign(config, jwtSecret);
    config.token = token;

    if (createEditor) createEditor.destroyEditor();

    editorButtons.innerHTML = `
        <button id="approveBtn" class="btn btn-success">Approve</button>
        <button id="closeReviewBtn" class="btn btn-secondary">Close</button>
    `;

    createEditor = new DocsAPI.DocEditor('editorWrapper', config);

    document.getElementById('approveBtn').onclick = async () => {
        try {
            const { error } = await supabaseClient
                .from(contractsTableName)
                .update({ valid: 'Done', updatedon: new Date().toISOString() })
                .eq('cid', cid)
                .eq('work', 'approval')
                .eq('valid', 'Pending');
            if (error) throw new Error(`Failed to approve: ${error.message}`);
            alert('Contract approved successfully!');
            createEditor.destroyEditor();
            editorContainer.style.display = 'none';
            templatesContent.classList.remove('hidden');
            showReviewers(document.getElementById('reviewersLink'));
        } catch (err) {
            console.error('Error approving contract:', err);
            alert(`Error: ${err.message}`);
        }
    };

    document.getElementById('closeReviewBtn').onclick = () => {
        createEditor.destroyEditor();
        editorContainer.style.display = 'none';
        templatesContent.classList.remove('hidden');
        showReviewers(document.getElementById('reviewersLink'));
    };
}

// Sign Contract
async function signContract(cid, contractsTableName) {
    const { data: contractData, error } = await supabaseClient
        .from(contractsTableName)
        .select('storage_path, title')
        .eq('cid', cid)
        .eq('work', 'signature')
        .eq('valid', 'Pending')
        .single();
    if (error || !contractData) {
        alert('Error fetching contract details.');
        return;
    }

    const editorContainer = document.getElementById('fullScreenEditor');
    const templatesContent = document.getElementById('templatesContent');
    const editorButtons = document.getElementById('editorButtons');

    templatesContent.classList.add('hidden');
    editorContainer.style.display = 'block';

    const baseUrl = 'http://192.168.4.37:3000';
    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
    const fileUrl = `${baseUrl}${contractData.storage_path}`;
    const username = localStorage.getItem('loggedInAdminUsername');
    const orgcode = (await supabaseClient.from('orgadmins').select('org_code').eq('organisation_name', localStorage.getItem('loggedInOrganisationName')).single()).data.org_code;

    const callbackUrl = `${baseUrl}/save-contract?tableName=${contractsTableName}&contractId=${cid}&contractTitle=${encodeURIComponent(contractData.title)}&orgcode=${orgcode}&username=${encodeURIComponent(username)}`;

    const config = {
        document: {
            fileType: 'docx',
            title: `${contractData.title}.docx`,
            url: fileUrl,
            key: `${cid}_${Date.now()}`,
            permissions: { edit: true, download: true }
        },
        documentType: 'word',
        editorConfig: {
            mode: 'edit',
            callbackUrl: callbackUrl,
            user: { id: username, name: username },
            lang: 'en'
        },
        height: '100%',
        width: '100%'
    };
    const token = jwt.sign(config, jwtSecret);
    config.token = token;

    if (createEditor) createEditor.destroyEditor();

    editorButtons.innerHTML = `
        <button id="signBtn" class="btn btn-success">Sign</button>
        <button id="closeSignBtn" class="btn btn-secondary">Close</button>
    `;

    createEditor = new DocsAPI.DocEditor('editorWrapper', config);

    document.getElementById('signBtn').onclick = async () => {
        try {
            const { error } = await supabaseClient
                .from(contractsTableName)
                .update({ valid: 'Done', updatedon: new Date().toISOString() })
                .eq('cid', cid)
                .eq('work', 'signature')
                .eq('valid', 'Pending');
            if (error) throw new Error(`Failed to sign: ${error.message}`);
            alert('Contract signed successfully!');
            createEditor.destroyEditor();
            editorContainer.style.display = 'none';
            templatesContent.classList.remove('hidden');
            showSignatures(document.getElementById('signaturesLink'));
        } catch (err) {
            console.error('Error signing contract:', err);
            alert(`Error: ${err.message}`);
        }
    };

    document.getElementById('closeSignBtn').onclick = () => {
        createEditor.destroyEditor();
        editorContainer.style.display = 'none';
        templatesContent.classList.remove('hidden');
        showSignatures(document.getElementById('signaturesLink'));
    };
}
async function createWorkflowDetailsTableIfNotExists(tableName) {
    try {
        const { data: tableExists, error: checkError } = await supabaseClient
            .rpc('check_contacts_table_exists', { table_name: tableName });
        if (checkError) throw new Error(`Error checking table existence: ${checkError.message}`);
        if (!tableExists) {
            const { error: createError } = await supabaseClient.rpc('run_contacts_sql', {
                sql_statement: `
                    CREATE TABLE ${tableName} (
                        id SERIAL PRIMARY KEY,
                        wid TEXT NOT NULL,
                        sequence INTEGER NOT NULL,
                        team TEXT,
                        approved_by TEXT,
                        signed_by TEXT,
                        approved_team_member TEXT,
                        signed_team_member TEXT
                    );
                `
            });
            if (createError) throw new Error(`Failed to create table ${tableName}: ${createError.message}`);
            console.log(`Created workflow details table: ${tableName}`);
        }
    } catch (err) {
        console.error('Error creating workflow details table:', err);
        throw err;
    }
}

// Show Workflow Tab Content
async function showWorkflow(element) {
    const teamContent = document.getElementById('templatesContent');
    const menuItems = document.querySelectorAll('.menu-item');
    menuItems.forEach(item => item.classList.remove('active'));
    element.parentElement.classList.add('active');

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    if (!organisationName) {
        alert('No admin logged in. Please log in first.');
        window.location.href = 'login.html';
        return;
    }

    const workflowTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_workflow`;

    teamContent.innerHTML = `
        <div class="card-header">
            <h5 class="mb-0">Workflows</h5>
        </div>
        <div class="card-body">
            <div class="mb-3">
                <button class="btn btn-primary waves-effect waves-light" onclick="openCreateWorkflowModal('${organisationName}')">Create New Workflow</button>
            </div>
            <div class="table-responsive">
                <table class="table table-bordered table-hover">
                    <thead class="table-light">
                        <tr>
                            <th>Workflow Name</th>
                            <th>Created On</th>
                            <th>Updated On</th>
                            <th>Status</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="workflowTableBody"></tbody>
                </table>
            </div>
        </div>
    `;

    await populateWorkflowTable(workflowTableName);
}

// Populate Workflow Table
async function populateWorkflowTable(workflowTableName) {
    const workflowTableBody = document.getElementById('workflowTableBody');
    workflowTableBody.innerHTML = '';

    try {
        const { data: workflows, error } = await supabaseClient
            .from(workflowTableName)
            .select('wid, workflow_name, created_on, updated_on, status')
            .order('created_on', { ascending: false });
        if (error && error.code !== '42P01') throw new Error(`Failed to fetch workflows: ${error.message}`);

        if (workflows && workflows.length > 0) {
            workflows.forEach(workflow => {
                const status = workflow.status || 'Active'; // Default to Active if not set
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${workflow.workflow_name}</td>
                    <td>${new Date(workflow.created_on).toLocaleString()}</td>
                    <td>${new Date(workflow.updated_on).toLocaleString()}</td>
                    <td><span class="badge ${status === 'Active' ? 'bg-label-success' : 'bg-label-danger'}">${status}</span></td>
                    <td class="action-buttons">
                        <button class="btn btn-sm btn-primary waves-effect waves-light edit-workflow-btn" data-wid="${workflow.wid}">Edit</button>
                        <button class="btn btn-sm btn-danger waves-effect waves-light disable-workflow-btn" data-wid W="${workflow.wid}">${status === 'Active' ? 'Disable' : 'Enable'}</button>
                    </td>
                `;
                workflowTableBody.appendChild(row);

                row.querySelector('.edit-workflow-btn').addEventListener('click', () => {
                    alert('Edit functionality not yet implemented.');
                });

                row.querySelector('.disable-workflow-btn').addEventListener('click', async () => {
                    const newStatus = status === 'Active' ? 'Disabled' : 'Active';
                    await toggleWorkflowStatus(workflow.wid, workflowTableName, newStatus);
                    populateWorkflowTable(workflowTableName);
                });
            });
        } else {
            workflowTableBody.innerHTML = '<tr><td colspan="5" class="text-center">No workflows found.</td></tr>';
        }
    } catch (err) {
        console.error('Error populating workflow table:', err);
        workflowTableBody.innerHTML = '<tr><td colspan="5" class="text-center">Error loading workflows.</td></tr>';
    }
}

// Toggle Workflow Status
async function toggleWorkflowStatus(wid, workflowTableName, newStatus) {
    try {
        const { error } = await supabaseClient
            .from(workflowTableName)
            .update({ status: newStatus, updated_on: new Date().toISOString() })
            .eq('wid', wid);
        if (error) throw new Error(`Failed to update workflow status: ${error.message}`);
    } catch (err) {
        console.error('Error toggling workflow status:', err);
        alert(`Error: ${err.message}`);
    }
}

async function openCreateWorkflowModal(orgName) {
    // Remove any existing modal to ensure a fresh start
    const existingModal = document.getElementById('createWorkflowModal');
    if (existingModal) {
        existingModal.remove();
    }

    const modalHtml = `
        <div class="modal fade" id="createWorkflowModal" tabindex="-1" aria-labelledby="createWorkflowModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="createWorkflowModalLabel">Create New Workflow</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="workflowName" class="form-label">Workflow Name</label>
                            <input type="text" class="form-control" id="workflowName" placeholder="Enter workflow name" required>
                        </div>
                        <div id="approvalContainer" class="approval-container">
                            <div id="internalApprovalContainer" class="approval-box" draggable="true" data-group="approval">
                                <h6>Internal Approval</h6>
                                <div class="form-check form-switch mb-2">
                                    <input class="form-check-input" type="checkbox" id="internalApprovalToggle">
                                    <label class="form-check-label" for="internalApprovalToggle">Enable</label>
                                </div>
                                <div id="internalApprovalOptions" class="d-none">
                                    <div class="approval-entry">
                                        <div class="row">
                                            <div class="col-md-6 mb-2">
                                                <select class="form-select internal-team-select" id="internalTeamSelect">
                                                    <option value="">Select Team</option>
                                                </select>
                                            </div>
                                            <div class="col-md-6 mb-2">
                                                <select class="form-select internal-role-select" id="internalRoleSelect">
                                                    <option value="">Select Role</option>
                                                    <option value="Team Head">Team Head</option>
                                                    <option value="Any Team Member">Any Team Member</option>
                                                    <option value="Specific Team Member">Specific Team Member</option>
                                                </select>
                                            </div>
                                        </div>
                                        <div class="internal-member-container d-none">
                                            <div class="row member-entry">
                                                <div class="col-md-10">
                                                    <select class="form-select internal-member-select" id="internalMemberSelect">
                                                        <option value="">Select Team Member</option>
                                                    </select>
                                                </div>
                                                <div class="col-md-2">
                                                    <button class="btn btn-outline-danger remove-member-btn">-</button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <button class="btn btn-outline-success add-approval-btn mt-2">+</button>
                                </div>
                            </div>
                            <div id="externalApprovalContainer" class="approval-box" draggable="true" data-group="approval">
                                <h6>External Approval</h6>
                                <div class="form-check form-switch mb-2">
                                    <input class="form-check-input" type="checkbox" id="externalApprovalToggle">
                                    <label class="form-check-label" for="externalApprovalToggle">Enable</label>
                                </div>
                            </div>
                        </div>
                        <hr class="my-4">
                        <div id="signatureContainer" class="signature-container">
                            <div id="internalSignatureContainer" class="signature-box" draggable="true" data-group="signature">
                                <h6>Internal Signature</h6>
                                <div class="form-check form-switch mb-2">
                                    <input class="form-check-input" type="checkbox" id="internalSignatureToggle">
                                    <label class="form-check-label" for="internalSignatureToggle">Enable</label>
                                </div>
                                <div id="internalSignatureOptions" class="d-none">
                                    <div class="row">
                                        <div class="col-md-6 mb-2">
                                            <select class="form-select internal-sig-team-select" id="internalSigTeamSelect">
                                                <option value="">Select Team</option>
                                            </select>
                                        </div>
                                        <div class="col-md-6 mb-2">
                                            <select class="form-select internal-sig-role-select" id="internalSigRoleSelect">
                                                <option value="">Select Role</option>
                                                <option value="Team Head">Team Head</option>
                                                <option value="Any Team Member">Any Team Member</option>
                                                <option value="Specific Team Member">Specific Team Member</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="internal-sig-member-container d-none">
                                        <div class="row member-entry">
                                            <div class="col-md-12">
                                                <select class="form-select internal-sig-member-select" id="internalSigMemberSelect">
                                                    <option value="">Select Team Member</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div id="externalSignatureContainer" class="signature-box" draggable="true" data-group="signature">
                                <h6>External Signature</h6>
                                <div class="form-check form-switch mb-2">
                                    <input class="form-check-input" type="checkbox" id="externalSignatureToggle">
                                    <label class="form-check-label" for="externalSignatureToggle">Enable</label>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="saveWorkflowBtn">Save</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);

    const modal = new bootstrap.Modal(document.getElementById('createWorkflowModal'));
    modal.show();

    // Populate Internal Approval Team Select
    const teamTableName = `${orgName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_teams`;
    const internalTeamSelect = document.getElementById('internalTeamSelect');
    try {
        const { data: teams, error } = await supabaseClient
            .from(teamTableName)
            .select('team_name');
        if (error && error.code !== '42P01') throw new Error(`Failed to fetch teams: ${error.message}`);
        if (teams) {
            teams.forEach(team => {
                internalTeamSelect.innerHTML += `<option value="${team.team_name}">${team.team_name}</option>`;
            });
        }
    } catch (err) {
        console.error('Error fetching teams:', err);
    }

    // Populate Internal Signature Team Select
    const internalSigTeamSelect = document.getElementById('internalSigTeamSelect');
    try {
        const { data: teams, error } = await supabaseClient
            .from(teamTableName)
            .select('team_name');
        if (error && error.code !== '42P01') throw new Error(`Failed to fetch teams: ${error.message}`);
        if (teams) {
            teams.forEach(team => {
                internalSigTeamSelect.innerHTML += `<option value="${team.team_name}">${team.team_name}</option>`;
            });
        }
    } catch (err) {
        console.error('Error fetching teams:', err);
    }

    // Toggle Internal Approval Options
    const internalApprovalToggle = document.getElementById('internalApprovalToggle');
    const internalApprovalOptions = document.getElementById('internalApprovalOptions');
    internalApprovalToggle.addEventListener('change', () => {
        internalApprovalOptions.classList.toggle('d-none', !internalApprovalToggle.checked);
    });

    // Toggle Internal Signature Options
    const internalSignatureToggle = document.getElementById('internalSignatureToggle');
    const internalSignatureOptions = document.getElementById('internalSignatureOptions');
    internalSignatureToggle.addEventListener('change', () => {
        internalSignatureOptions.classList.toggle('d-none', !internalSignatureToggle.checked);
    });

    // Handle Internal Approval Role Selection
    const internalRoleSelect = document.getElementById('internalRoleSelect');
    const internalMemberContainer = document.querySelector('#internalApprovalOptions .internal-member-container');
    internalRoleSelect.addEventListener('change', async () => {
        const role = internalRoleSelect.value;
        internalMemberContainer.classList.toggle('d-none', role !== 'Specific Team Member');
        if (role === 'Specific Team Member') {
            await populateInternalMemberSelect(orgName, internalTeamSelect.value);
        }
    });

    // Handle Internal Signature Role Selection
    const internalSigRoleSelect = document.getElementById('internalSigRoleSelect');
    const internalSigMemberContainer = document.querySelector('.internal-sig-member-container');
    internalSigRoleSelect.addEventListener('change', async () => {
        const role = internalSigRoleSelect.value;
        internalSigMemberContainer.classList.toggle('d-none', role !== 'Specific Team Member');
        if (role === 'Specific Team Member') {
            await populateInternalMemberSelect(orgName, internalSigTeamSelect.value, document.getElementById('internalSigMemberSelect'));
        }
    });

    // Handle Internal Approval Team Selection Change
    internalTeamSelect.addEventListener('change', async () => {
        if (internalRoleSelect.value === 'Specific Team Member') {
            await populateInternalMemberSelect(orgName, internalTeamSelect.value);
        }
    });

    // Handle Internal Signature Team Selection Change
    internalSigTeamSelect.addEventListener('change', async () => {
        if (internalSigRoleSelect.value === 'Specific Team Member') {
            await populateInternalMemberSelect(orgName, internalSigTeamSelect.value, document.getElementById('internalSigMemberSelect'));
        }
    });

    // Add More Approval Entries (Team and Role Dropdowns)
    document.querySelector('.add-approval-btn').addEventListener('click', () => {
        const newEntry = document.createElement('div');
        newEntry.className = 'approval-entry mt-2';
        newEntry.innerHTML = `
            <div class="row">
                <div class="col-md-6 mb-2">
                    <select class="form-select internal-team-select">
                        <option value="">Select Team</option>
                        ${internalTeamSelect.innerHTML}
                    </select>
                </div>
                <div class="col-md-6 mb-2">
                    <select class="form-select internal-role-select">
                        <option value="">Select Role</option>
                        <option value="Team Head">Team Head</option>
                        <option value="Any Team Member">Any Team Member</option>
                        <option value="Specific Team Member">Specific Team Member</option>
                    </select>
                </div>
            </div>
            <div class="internal-member-container d-none">
                <div class="row member-entry">
                    <div class="col-md-10">
                        <select class="form-select internal-member-select">
                            <option value="">Select Team Member</option>
                        </select>
                    </div>
                    <div class="col-md-2">
                        <button class="btn btn-outline-danger remove-member-btn">-</button>
                    </div>
                </div>
            </div>
            <button class="btn btn-outline-danger remove-approval-btn mt-2">-</button>
        `;
        internalApprovalOptions.insertBefore(newEntry, document.querySelector('.add-approval-btn'));

        const newRoleSelect = newEntry.querySelector('.internal-role-select');
        const newTeamSelect = newEntry.querySelector('.internal-team-select');
        const newMemberContainer = newEntry.querySelector('.internal-member-container');

        newRoleSelect.addEventListener('change', async () => {
            const role = newRoleSelect.value;
            newMemberContainer.classList.toggle('d-none', role !== 'Specific Team Member');
            if (role === 'Specific Team Member') {
                await populateInternalMemberSelect(orgName, newTeamSelect.value, newMemberContainer.querySelector('.internal-member-select'));
            }
        });

        newTeamSelect.addEventListener('change', async () => {
            if (newRoleSelect.value === 'Specific Team Member') {
                await populateInternalMemberSelect(orgName, newTeamSelect.value, newMemberContainer.querySelector('.internal-member-select'));
            }
        });

        newEntry.querySelector('.remove-approval-btn').addEventListener('click', () => {
            newEntry.remove();
        });
    });

    // Drag-and-Drop Functionality for Approval Container
    const approvalContainer = document.getElementById('approvalContainer');
    const approvalBoxes = approvalContainer.querySelectorAll('.approval-box');
    setupDragAndDrop(approvalContainer, approvalBoxes, 'approval');

    // Drag-and-Drop Functionality for Signature Container
    const signatureContainer = document.getElementById('signatureContainer');
    const signatureBoxes = signatureContainer.querySelectorAll('.signature-box');
    setupDragAndDrop(signatureContainer, signatureBoxes, 'signature');

    // Save Workflow with Details
    document.getElementById('saveWorkflowBtn').addEventListener('click', async () => {
        const workflowName = document.getElementById('workflowName').value.trim();
        if (!workflowName) {
            alert('Please enter a workflow name.');
            return;
        }

        const workflowTableName = `${orgName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_workflow`;
        const workflowDetailsTableName = `${orgName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_workflowdetails`;
        await createWorkflowTableIfNotExists(workflowTableName);
        await createWorkflowDetailsTableIfNotExists(workflowDetailsTableName);

        const wid = `wf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const createdBy = localStorage.getItem('loggedInAdminUsername');
        const now = new Date().toISOString();

        // Determine Approval Order and State
        const approvalChildren = Array.from(approvalContainer.children);
        const internalApprovalIndex = approvalChildren.findIndex(child => child.id === 'internalApprovalContainer');
        const externalApprovalIndex = approvalChildren.findIndex(child => child.id === 'externalApprovalContainer');
        const internalApprovalEnabled = document.getElementById('internalApprovalToggle').checked;
        const externalApprovalEnabled = document.getElementById('externalApprovalToggle').checked;

        const internalApprovalValue = internalApprovalEnabled 
            ? (internalApprovalIndex < externalApprovalIndex ? 'enable_1' : 'enable_2') 
            : 'disable';
        const externalApprovalValue = externalApprovalEnabled 
            ? (externalApprovalIndex < internalApprovalIndex ? 'enable_1' : 'enable_2') 
            : 'disable';

        // Determine Signature Order and State
        const signatureChildren = Array.from(signatureContainer.children);
        const internalSignatureIndex = signatureChildren.findIndex(child => child.id === 'internalSignatureContainer');
        const externalSignatureIndex = signatureChildren.findIndex(child => child.id === 'externalSignatureContainer');
        const internalSignatureEnabled = document.getElementById('internalSignatureToggle').checked;
        const externalSignatureEnabled = document.getElementById('externalSignatureToggle').checked;

        const internalSignatureValue = internalSignatureEnabled 
            ? (internalSignatureIndex < externalSignatureIndex ? 'enable_3' : 'enable_4') 
            : 'disable';
        const externalSignatureValue = externalSignatureEnabled 
            ? (externalSignatureIndex < internalSignatureIndex ? 'enable_3' : 'enable_4') 
            : 'disable';

        const workflowData = {
            wid,
            workflow_name: workflowName,
            created_by: createdBy,
            created_on: now,
            updated_on: now,
            internal_approval: internalApprovalValue,
            internal_signature: internalSignatureValue,
            external_approval: externalApprovalValue,
            external_signature: externalSignatureValue,
            status: 'Active'
        };

        // Collect Internal Approval Details
        const workflowDetails = [];
        if (internalApprovalEnabled) {
            const approvalEntries = document.querySelectorAll('#internalApprovalOptions .approval-entry');
            approvalEntries.forEach((entry, index) => {
                const team = entry.querySelector('.internal-team-select').value || null;
                const approvedBy = entry.querySelector('.internal-role-select').value || null;
                const approvedTeamMember = approvedBy === 'Specific Team Member' 
                    ? (entry.querySelector('.internal-member-select')?.value || null) 
                    : null;

                if (team) { // Only add if a team is selected
                    workflowDetails.push({
                        wid,
                        sequence: index + 1,
                        team,
                        approved_by: approvedBy,
                        signed_by: null,
                        approved_team_member: approvedTeamMember,
                        signed_team_member: null
                    });
                }
            });
        }

        // Collect Internal Signature Details
        if (internalSignatureEnabled) {
            const sigTeam = document.getElementById('internalSigTeamSelect').value || null;
            const signedBy = document.getElementById('internalSigRoleSelect').value || null;
            const signedTeamMember = signedBy === 'Specific Team Member' 
                ? (document.getElementById('internalSigMemberSelect')?.value || null) 
                : null;

            if (sigTeam) { // Only add if a team is selected
                workflowDetails.push({
                    wid,
                    sequence: 1, // Only one entry for Internal Signature
                    team: sigTeam,
                    approved_by: null,
                    signed_by: signedBy,
                    approved_team_member: null,
                    signed_team_member: signedTeamMember
                });
            }
        }

        try {
            // Insert into workflow table
            const { error: workflowError } = await supabaseClient
                .from(workflowTableName)
                .insert(workflowData);
            if (workflowError) throw new Error(`Failed to save workflow: ${workflowError.message}`);

            // Insert into workflow details table if there are details
            if (workflowDetails.length > 0) {
                const { error: detailsError } = await supabaseClient
                    .from(workflowDetailsTableName)
                    .insert(workflowDetails);
                if (detailsError) throw new Error(`Failed to save workflow details: ${detailsError.message}`);
            }

            modal.hide();
            showWorkflow(document.getElementById('workflowLink'));
        } catch (err) {
            console.error('Error saving workflow:', err);
            alert(`Error: ${err.message}`);
        }
    });
}

// Helper Function for Drag-and-Drop
function setupDragAndDrop(container, boxes, group) {
    boxes.forEach(box => {
        box.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', box.id);
            setTimeout(() => {
                box.classList.add('dragging');
            }, 0);
        });

        box.addEventListener('dragend', (e) => {
            box.classList.remove('dragging');
        });
    });

    container.addEventListener('dragover', (e) => {
        e.preventDefault();
    });

    container.addEventListener('drop', (e) => {
        e.preventDefault();
        const draggedId = e.dataTransfer.getData('text/plain');
        const draggedBox = document.getElementById(draggedId);
        const targetBox = e.target.closest(`[data-group="${group}"]`);

        if (draggedBox && targetBox && draggedBox !== targetBox && draggedBox.dataset.group === group) {
            const rect = targetBox.getBoundingClientRect();
            const isAbove = e.clientY < rect.top + rect.height / 2;

            if (isAbove) {
                container.insertBefore(draggedBox, targetBox);
            } else {
                container.insertBefore(draggedBox, targetBox.nextSibling);
            }

            draggedBox.style.transition = 'transform 0.3s ease';
            targetBox.style.transition = 'transform 0.3s ease';
            setTimeout(() => {
                draggedBox.style.transform = 'none';
                targetBox.style.transform = 'none';
            }, 300);
        }
    });
}

// Updated populateInternalMemberSelect to support custom select elements
async function populateInternalMemberSelect(orgName, teamName, selectElement = document.getElementById('internalMemberSelect')) {
    selectElement.innerHTML = '<option value="">Select Team Member</option>';
    try {
        const { data: users, error } = await supabaseClient
            .from('users')
            .select('email')
            .eq('organisation', orgName)
            .eq('team_type', teamName);
        if (error) throw new Error(`Failed to fetch team members: ${error.message}`);
        if (users) {
            users.forEach(user => {
                selectElement.innerHTML += `<option value="${user.email}">${user.email}</option>`;
            });
        }
    } catch (err) {
        console.error('Error fetching team members:', err);
    }
}

// Create Workflow Table If Not Exists
async function createWorkflowTableIfNotExists(tableName) {
    try {
        const { data: tableExists, error: checkError } = await supabaseClient
            .rpc('check_contacts_table_exists', { table_name: tableName });
        if (checkError) throw new Error(`Error checking table existence: ${checkError.message}`);
        if (!tableExists) {
            const { error: createError } = await supabaseClient.rpc('run_contacts_sql', {
                sql_statement: `
                    CREATE TABLE ${tableName} (
                        wid TEXT PRIMARY KEY,
                        workflow_name TEXT NOT NULL,
                        created_by TEXT NOT NULL,
                        created_on TIMESTAMP NOT NULL,
                        updated_on TIMESTAMP NOT NULL,
                        internal_approval TEXT,
                        internal_signature TEXT,
                        external_approval TEXT,
                        external_signature TEXT,
                        status TEXT DEFAULT 'Active'
                    );
                `
            });
            if (createError) throw new Error(`Failed to create table ${tableName}: ${createError.message}`);
            console.log(`Created workflow table: ${tableName}`);
        }
    } catch (err) {
        console.error('Error creating workflow table:', err);
        throw err;
    }
}

// Add Event Listener for Workflow Link
document.getElementById('workflowLink').addEventListener('click', function(e) {
    e.preventDefault();
    showWorkflow(this);
});


function logToStorage(message) {
    const logs = JSON.parse(localStorage.getItem('debugLogs') || '[]'); // Keep last 100 logs
    console.log(message);
}
async function ensureStoragePathPdfColumn(contractsTableName) {
    try {
        console.log(`Checking for storage_path_pdf column in ${contractsTableName}`);
        const { data: columns, error: checkError } = await supabaseClient
            .rpc('check_column_exists', {
                p_table_name: contractsTableName,
                p_column_name: 'storage_path_pdf'
            });
        if (checkError) {
            console.error('Error checking column:', checkError);
            throw new Error(`Failed to check column: ${checkError.message}`);
        }

        if (!columns) {
            console.log(`Creating storage_path_pdf column in ${contractsTableName}`);
            const { error: createError } = await supabaseClient.rpc('run_contacts_sql', {
                sql_statement: `
                    ALTER TABLE ${contractsTableName}
                    ADD COLUMN storage_path_pdf TEXT;
                `
            });
            if (createError) {
                console.error('Error creating column:', createError);
                throw new Error(`Failed to create column: ${createError.message}`);
            }
            console.log(`Created storage_path_pdf column`);
        } else {
            console.log(`storage_path_pdf column already exists`);
        }
    } catch (err) {
        console.error('Error ensuring storage_path_pdf column:', err);
        throw err;
    }
}

// Convert .docx to .pdf and update storage_path_pdf
async function convertDocxToPdfAndUpdate(contractsTableName, cid) {
    try {
        // Fetch all rows for the cid
        console.log(`Fetching contracts for cid: ${cid} in ${contractsTableName}`);
        const { data: contractData, error: fetchError } = await supabaseClient
            .from(contractsTableName)
            .select('storage_path, storage_path_pdf')
            .eq('cid', cid);
        if (fetchError) {
            console.error('Error fetching contracts:', JSON.stringify(fetchError, null, 2));
            throw new Error(`Failed to fetch contracts: ${fetchError.message}`);
        }

        console.log(`Rows returned for cid ${cid}: ${contractData?.length || 0}`);
        if (!contractData || contractData.length === 0) {
            console.error('No rows found for cid:', cid);
            throw new Error('No contracts found for the given cid');
        }

        // Check if storage_path is consistent across rows
        const docxPath = contractData[0].storage_path;
        if (!docxPath) {
            console.error('No storage_path for cid:', cid);
            throw new Error('Contract has no storage_path');
        }

        // Optional: Warn if storage_path differs (remove if not needed)
        const inconsistentPaths = contractData.some(row => row.storage_path !== docxPath);
        if (inconsistentPaths) {
            console.warn(`Multiple storage_path values found for cid ${cid}. Using: ${docxPath}`);
            // Optional: Throw error instead
            // throw new Error(`Inconsistent storage_path values for cid ${cid}`);
        }

        // Convert .docx to .pdf (only once)
        const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
        const token = jwt.sign({}, jwtSecret);
        console.log(`Converting .docx to .pdf: ${docxPath}`);
        const response = await fetch('http://192.168.4.37:3000/convert-to-pdf', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ docxPath })
        });

        if (!response.ok) {
            const errorData = await response.json();
            console.error('Conversion failed:', JSON.stringify(errorData, null, 2));
            throw new Error(`Failed to convert to PDF: ${errorData.error} - ${errorData.details}`);
        }

        const { pdfPath } = await response.json();
        console.log(`PDF created at: ${pdfPath}`);

        // Update storage_path_pdf for all rows with the same cid
        const { error: updateError } = await supabaseClient
            .from(contractsTableName)
            .update({ storage_path_pdf: pdfPath })
            .eq('cid', cid);
        if (updateError) {
            console.error('Error updating storage_path_pdf:', JSON.stringify(updateError, null, 2));
            throw new Error(`Failed to update storage_path_pdf: ${updateError.message}`);
        }

        console.log(`Updated storage_path_pdf to ${pdfPath} for all rows with cid: ${cid}`);
    } catch (err) {
        console.error('Error in convertDocxToPdfAndUpdate:', err);
        throw err;
    }
}
async function openPdfEditorPopup(cid, contractsTableName) {
    logToStorage(`Opening PDF editor popup for cid: ${cid}`);

    // Create modal elements
    const modal = document.createElement('div');
    modal.className = 'pdf-editor-modal';
    modal.id = 'pdf-editor-modal';

    const modalContent = document.createElement('div');
    modalContent.className = 'pdf-editor-content';

    const closeBtn = document.createElement('button');
    closeBtn.className = 'close-btn';
    closeBtn.innerHTML = '×';
    closeBtn.onclick = () => {
        logToStorage('Closing PDF editor popup');
        modal.remove();
    };

    const pdfEditor = document.createElement('div');
    pdfEditor.id = 'pdf-editor';
    pdfEditor.innerHTML = `
        <div id="pdf-controls">
            <button id="add-signature">Add Signature</button>
            <button id="add-text">Add Text</button>
            <button id="ok-button">OK</button>
        </div>
        <div id="pdf-viewer-container">
            <canvas id="fabric-canvas"></canvas>
        </div>
    `;

    modalContent.appendChild(closeBtn);
    modalContent.appendChild(pdfEditor);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);

    // Show modal
    modal.style.display = 'flex';

    // Call showPdfEditor
    try {
        await showPdfEditor(cid, contractsTableName, pdfEditor);
        logToStorage('PDF editor popup initialized');
    } catch (err) {
        logToStorage(`Failed to initialize PDF editor: ${err.message}`);
        alert(`Error: ${err.message}`);
        modal.remove();
        throw err;
    }
}
async function showPdfEditor(cid, contractsTableName, containerElement) {
    logToStorage(`Starting showPdfEditor for cid: ${cid}`);
    let fabricCanvas = null;
    try {
        const pdfEditor = containerElement || document.getElementById('pdf-editor');
        const fabricCanvasEl = pdfEditor.querySelector('#fabric-canvas');

        if (!pdfEditor || !fabricCanvasEl) {
            logToStorage('DOM elements missing: #pdf-editor or #fabric-canvas');
            throw new Error('Required DOM elements missing');
        }

        // Fetch storage_path_pdf
        let contractData = null;
        for (let attempt = 1; attempt <= 5; attempt++) {
            logToStorage(`Fetching storage_path_pdf for cid: ${cid} (Attempt ${attempt})`);
            try {
                const result = await supabaseClient
                    .from(contractsTableName)
                    .select('storage_path_pdf')
                    .eq('cid', cid)
                    .limit(1)
                    .single();
                if (result.error) throw result.error;
                contractData = result.data;
                break;
            } catch (err) {
                if (attempt < 5) {
                    await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
                    continue;
                }
                throw new Error(`Failed to fetch PDF path after ${attempt} attempts: ${err.message}`);
            }
        }

        if (!contractData?.storage_path_pdf) throw new Error('No storage_path_pdf found');
        const pdfPath = contractData.storage_path_pdf;
        logToStorage(`Retrieved pdfPath: ${pdfPath}`);
        const pdfUrl = `http://192.168.4.37:3000/files${pdfPath}`;
        logToStorage(`Testing PDF URL: ${pdfUrl}`);

        // Verify PDF accessibility
        try {
            const urlTest = await fetch(pdfUrl, { method: 'HEAD' });
            if (!urlTest.ok) throw new Error(`PDF URL inaccessible: ${urlTest.status} ${urlTest.statusText}`);
        } catch (urlError) {
            throw new Error(`Cannot access PDF at ${pdfUrl}: ${urlError.message}`);
        }

        // Load Fabric.js
        logToStorage('Loading Fabric.js');
        if (!window.fabric) {
            const fabricScript = document.createElement('script');
            fabricScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js';
            document.head.appendChild(fabricScript);
            await new Promise((resolve, reject) => {
                fabricScript.onload = () => {
                    logToStorage('Fabric.js 5.3.1 loaded successfully');
                    resolve();
                };
                fabricScript.onerror = (e) => reject(new Error(`Failed to load Fabric.js: ${e.message}`));
            });
        }

        // Load PDFLib
        logToStorage('Loading PDFLib');
        if (!window.PDFLib) {
            const pdfLibScript = document.createElement('script');
            pdfLibScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js';
            document.head.appendChild(pdfLibScript);
            await new Promise((resolve, reject) => {
                pdfLibScript.onload = () => {
                    logToStorage('PDFLib 1.17.1 loaded successfully');
                    resolve();
                };
                pdfLibScript.onerror = (e) => reject(new Error(`Failed to load PDFLib: ${e.message}`));
            });
        }

        // Load and render PDF
        const pdf = await window.pdfjsLib.getDocument(pdfUrl).promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 1.0 });

        logToStorage(`Setting up canvas: ${viewport.width}x${viewport.height}`);
        fabricCanvasEl.width = viewport.width;
        fabricCanvasEl.height = viewport.height;
        fabricCanvasEl.style.width = `${viewport.width}px`;
        fabricCanvasEl.style.height = `${viewport.height}px`;
        fabricCanvasEl.style.pointerEvents = 'auto';
        fabricCanvasEl.style.position = 'relative';
        fabricCanvasEl.style.zIndex = '10';

        fabricCanvas = new fabric.Canvas(fabricCanvasEl, {
            width: viewport.width,
            height: viewport.height,
            selection: true,
            hoverCursor: 'move',
            defaultCursor: 'default',
            perPixelTargetFind: true,
            targetFindTolerance: 10
        });
        if (!fabricCanvas) throw new Error('Fabric.js canvas initialization failed');
        logToStorage('Fabric.js canvas initialized');

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = viewport.width;
        tempCanvas.height = viewport.height;
        const context = tempCanvas.getContext('2d');
        await page.render({ canvasContext: context, viewport: viewport }).promise;

        const pdfImage = new fabric.Image(tempCanvas, {
            left: 0,
            top: 0,
            selectable: false,
            evented: false
        });
        fabricCanvas.add(pdfImage);
        fabricCanvas.sendToBack(pdfImage);
        logToStorage('PDF added as background image');

        // Add Signature with email prompt
        const addSignatureBtn = pdfEditor.querySelector('#add-signature');
        if (addSignatureBtn) {
            addSignatureBtn.onclick = () => {
                logToStorage('Adding signature placeholder');
                let email = prompt('Enter the email for this signature placeholder:');
                if (!email) {
                    logToStorage('No email provided, canceling signature addition');
                    return;
                }

                const signatureRect = new fabric.Rect({
                    left: 50,
                    top: 50,
                    width: 150,
                    height: 50,
                    fill: 'transparent',
                    stroke: 'black',
                    strokeWidth: 2,
                    hasControls: true,
                    hasBorders: true,
                    lockMovementX: false,
                    lockMovementY: false,
                    lockScalingX: false,
                    lockScalingY: false,
                    lockRotation: true,
                    selectable: true,
                    evented: true
                });

                const emailText = new fabric.Text(email, {
                    left: 75, // Centered horizontally
                    top: 25,  // Centered vertically
                    fontSize: 12,
                    originX: 'center',
                    originY: 'center',
                    fill: 'black',
                    selectable: false,
                    evented: false
                });

                const signatureGroup = new fabric.Group([signatureRect, emailText], {
                    left: 50,
                    top: 50,
                    hasControls: true,
                    hasBorders: true,
                    lockMovementX: false,
                    lockMovementY: false,
                    lockScalingX: false,
                    lockScalingY: false,
                    lockRotation: true,
                    selectable: true,
                    evented: true,
                    subTargetCheck: true
                });

                signatureGroup.on('selected', () => {
                    logToStorage('Signature group selected');
                    fabricCanvas.setActiveObject(signatureGroup);
                    logToStorage(`Active object: ${fabricCanvas.getActiveObject()?.type}, position: (${signatureGroup.left}, ${signatureGroup.top}), email: ${email}`);
                });
                signatureGroup.on('moving', () => logToStorage('Signature group moving'));
                signatureGroup.on('scaling', () => logToStorage('Signature group scaling'));
                signatureGroup.on('mousedown', () => logToStorage('Signature group mousedown'));

                fabricCanvas.add(signatureGroup);
                fabricCanvas.setActiveObject(signatureGroup);
                fabricCanvas.bringToFront(signatureGroup);
                fabricCanvas.renderAll();
                logToStorage(`Signature group added at (${signatureGroup.left}, ${signatureGroup.top}), controls: ${signatureGroup.hasControls}, email: ${email}`);
            };
        }

        // OK Button with save to original PDF
        const okButton = pdfEditor.querySelector('#ok-button');
        if (okButton) {
            okButton.onclick = async () => {
                try {
                    logToStorage('Saving PDF edits');
                    const pdfResponse = await fetch(pdfUrl);
                    const pdfBytes = await pdfResponse.arrayBuffer();

                    // Convert ArrayBuffer to base64 in browser
                    const binary = new Uint8Array(pdfBytes);
                    let base64String = '';
                    for (let i = 0; i < binary.length; i++) {
                        base64String += String.fromCharCode(binary[i]);
                    }
                    const pdfBase64 = btoa(base64String);

                    const fabricObjects = fabricCanvas.getObjects();
                    const annotations = {
                        objects: fabricObjects
                            .filter(obj => obj.type === 'group' && obj._objects[0].type === 'rect')
                            .map(obj => {
                                const rect = obj._objects[0];
                                const emailText = obj.getObjects().find(o => o.type === 'text');
                                const email = emailText ? emailText.text : 'Unknown';
                                return {
                                    name: 'signature',
                                    left: obj.left,
                                    top: 612 - obj.top - rect.height,
                                    width: rect.width,
                                    height: rect.height,
                                    strokeWidth: rect.strokeWidth || 2,
                                    email: email // Add email as a direct property
                                };
                            })
                    };

                    if (annotations.objects.length === 0) {
                        logToStorage('No annotations to save');
                        throw new Error('No signature placeholders to save');
                    }

                    logToStorage(`Annotations prepared: ${JSON.stringify(annotations)}`);

                    // Send JSON payload
                    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
                    const token = jwt.sign({}, jwtSecret);
                    const response = await fetch('http://192.168.4.37:3000/annotate-pdf', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ pdfPath, annotations, pdf: pdfBase64 })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const errorData = await response.json().catch(() => ({ error: errorText }));
                        logToStorage(`Failed to save PDF: Raw response: ${errorText}, Parsed: ${JSON.stringify(errorData)}`);
                        throw new Error(`Failed to save PDF: ${errorData.error} - ${errorData.details || errorText}`);
                    }

                    const { updatedPdfPath } = await response.json();
                    logToStorage(`Annotated PDF saved at: ${updatedPdfPath}`);

                    if (updatedPdfPath === pdfPath) {
                        logToStorage('PDF successfully overwritten at original path');
                    } else {
                        const { error: updateError } = await supabaseClient
                            .from(contractsTableName)
                            .update({ storage_path_pdf: updatedPdfPath })
                            .eq('cid', cid);
                        if (updateError) {
                            logToStorage(`Failed to update storage_path_pdf: ${JSON.stringify(updateError)}`);
                            throw new Error(`Failed to update storage_path_pdf: ${updateError.message}`);
                        }
                    }

                    logToStorage('Closing PDF editor popup');
                    const modal = document.getElementById('pdf-editor-modal');
                    if (modal) modal.remove();
                    fabricCanvas.dispose();
                    fabricCanvas = null;

                    await populateContractsInProgressTable(contractsTableName);
                    alert('PDF edits saved successfully!');
                } catch (err) {
                    logToStorage(`Error saving PDF: ${err.message}`);
                    alert(`Error saving PDF: ${err.message}`);
                    const modal = document.getElementById('pdf-editor-modal');
                    if (modal) modal.remove();
                }
            };
        }

    } catch (err) {
        logToStorage(`Error in showPdfEditor for cid ${cid}: ${err.message}`);
        if (fabricCanvas) fabricCanvas.dispose();
        throw err;
    }
}
// Show Contracts In Progress (updated for overlay)
let contractsSubscription = null;
async function showContractsInProgress(element) {
    logToStorage('Showing Contracts In Progress');
    const teamContent = document.getElementById('templatesContent');
    if (!teamContent) {
        logToStorage('Error: #templatesContent element not found');
        alert('Error: Page content area not found.');
        return;
    }

    teamContent.classList.remove('hidden');

    if (!supabaseClient) {
        logToStorage('Supabase client not initialized');
        alert('Error: Database connection not ready.');
        return;
    }

    const menuItems = document.querySelectorAll('.menu-item');
    menuItems.forEach(item => item.classList.remove('active'));
    element.closest('.menu-item').classList.add('active');
    element.closest('.menu-sub')?.querySelectorAll('.menu-link').forEach(link => link.classList.remove('active'));
    element.classList.add('active');

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    if (!organisationName) {
        logToStorage('No admin logged in');
        alert('No admin logged in. Please log in first.');
        window.location.href = 'login.html';
        return;
    }

    const contractsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;
    logToStorage(`Contracts table name: ${contractsTableName}`);

    // Check for openPdfAfterReload before rendering content
    const openPdfData = localStorage.getItem('openPdfAfterReload');
    logToStorage(`openPdfAfterReload value: ${openPdfData}`);
    let popupTriggered = false;

    if (openPdfData) {
        try {
            const { cid, contractsTableName: storedTableName } = JSON.parse(openPdfData);
            logToStorage(`Parsed openPdfAfterReload: cid=${cid}, table=${storedTableName}`);
            if (storedTableName === contractsTableName) {
                logToStorage(`Checking contract status for cid ${cid}`);
                const { data: allRows, error } = await supabaseClient
                    .from(contractsTableName)
                    .select('id, stage, status, storage_path_pdf, updatedon')
                    .eq('cid', cid)
                    .order('updatedon', { ascending: false });

                if (error) {
                    logToStorage(`Query error: ${JSON.stringify(error)}`);
                    throw new Error(`Failed to fetch contract: ${error.message}`);
                }

                logToStorage(`All rows for cid ${cid}: ${JSON.stringify(allRows)}`);

                if (!allRows || allRows.length === 0) {
                    logToStorage(`No rows found for cid ${cid}`);
                    throw new Error(`No contract found for cid ${cid}`);
                }

                const contractData = allRows[0]; // Select latest row
                logToStorage(`Selected contract data: stage=${contractData.stage}, status=${contractData.status}, pdf=${contractData.storage_path_pdf}, updatedon=${contractData.updatedon}`);

                if (contractData.stage === 'Draft' && contractData.status === 'Completed' && contractData.storage_path_pdf) {
                    logToStorage(`Scheduling PDF popup for cid ${cid} after DOM load`);
                    setTimeout(async () => {
                        try {
                            logToStorage(`Triggering PDF popup for cid ${cid}`);
                            await openPdfEditorPopup(cid, contractsTableName);
                            popupTriggered = true;
                            logToStorage('PDF popup opened successfully');
                        } catch (err) {
                            logToStorage(`Failed to open PDF popup: ${err.message}`);
                            alert(`Error opening PDF: ${err.message}`);
                        } finally {
                            logToStorage('Clearing openPdfAfterReload after popup attempt');
                            localStorage.removeItem('openPdfAfterReload');
                        }
                    }, 4000); // Increased to 4 seconds
                } else {
                    logToStorage(`Contract cid ${cid} not eligible for popup (stage: ${contractData.stage}, status: ${contractData.status}, pdf: ${contractData.storage_path_pdf})`);
                    localStorage.removeItem('openPdfAfterReload');
                }
            } else {
                logToStorage(`Table mismatch: stored=${storedTableName}, current=${contractsTableName}`);
                localStorage.removeItem('openPdfAfterReload');
            }
        } catch (err) {
            logToStorage(`Error processing openPdfAfterReload: ${err.message}`);
            localStorage.removeItem('openPdfAfterReload');
        }
    } else {
        logToStorage('No openPdfAfterReload found in localStorage');
    }

    // Render content
    teamContent.innerHTML = `
        <div id="main-content">
            <div class="card" id="in-progress-table">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Contracts In Progress</h5>
                    <button class="btn btn-primary" id="createNewContractBtn">Create New Contract</button>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-bordered table-hover">
                            <thead class="table-light">
                                <tr>
                                    <th>Agreement Title</th>
                                    <th>Account Name</th>
                                    <th>Created On</th>
                                    <th>Updated On</th>
                                    <th>Stage</th>
                                    <th>Status</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody id="contractsInProgressTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    `;

    logToStorage('Attaching create contract button listener');
    document.getElementById('createNewContractBtn').addEventListener('click', () => {
        logToStorage('Create New Contract clicked');
        openCreateContractModal(organisationName);
    });

    logToStorage('Populating contracts table');
    await populateContractsInProgressTable(contractsTableName);

    if (contractsSubscription) {
        logToStorage('Unsubscribing existing subscription');
        contractsSubscription.unsubscribe();
    }

    logToStorage('Setting up real-time subscription');
    contractsSubscription = supabaseClient
        .channel(`realtime:${contractsTableName}`)
        .on(
            'postgres_changes',
            {
                event: 'UPDATE',
                schema: 'public',
                table: contractsTableName
            },
            async (payload) => {
                logToStorage(`Real-time update: ${JSON.stringify(payload)}`);
                const oldData = payload.old;
                const newData = payload.new;

                if (oldData.stage !== newData.stage || oldData.status !== newData.status) {
                    logToStorage('Stage or status changed, scheduling reload');
                    if (!localStorage.getItem('reloadScheduled')) {
                        localStorage.setItem('reloadScheduled', 'true');
                        setTimeout(() => {
                            logToStorage('Reloading page');
                            localStorage.setItem('activeTab', 'inProgress');
                            localStorage.setItem('refreshReason', 'stageStatusChange');
                            localStorage.removeItem('reloadScheduled');
                            window.location.reload();
                        }, 5000);
                    } else {
                        logToStorage('Reload already scheduled, skipping');
                    }
                } else {
                    logToStorage('Refreshing table without reload');
                    await populateContractsInProgressTable(contractsTableName);
                }

                if (newData.stage === 'Under Review – External' && newData.status === 'In Progress') {
                    logToStorage(`Sending external review email for cid: ${newData.cid}`);
                    await sendExternalReviewEmail(newData, contractsTableName);
                }
            }
        )
        .subscribe((status) => {
            logToStorage(`Subscription status: ${status}`);
            if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status === 'CLOSED') {
                logToStorage(`Subscription issue detected: ${status}. Attempting to open popup directly for cid in localStorage.`);
                const openPdfDataFallback = localStorage.getItem('openPdfAfterReload');
                if (openPdfDataFallback) {
                    const { cid, contractsTableName } = JSON.parse(openPdfDataFallback);
                    logToStorage(`Fallback: Triggering popup for cid ${cid}`);
                    setTimeout(async () => {
                        try {
                            await openPdfEditorPopup(cid, contractsTableName);
                            logToStorage('Fallback popup opened successfully');
                            localStorage.removeItem('openPdfAfterReload');
                        } catch (err) {
                            logToStorage(`Fallback popup failed: ${err.message}`);
                        }
                    }, 4000);
                }
            }
        });

    if (element.id === 'contractsInProgressLink') {
        localStorage.setItem('activeTab', 'inProgress');
        localStorage.removeItem('refreshReason');
    }
}
// Populate Contracts In Progress Table
// Populate Contracts In Progress Table
async function populateContractsInProgressTable(contractsTableName) {
    const tbody = document.getElementById('contractsInProgressTableBody');
    tbody.innerHTML = '';

    try {
        const { data: contractsData, error } = await supabaseClient
            .from(contractsTableName)
            .select('cid, title, accountname, createdon, updatedon, stage, status')
            .order('updatedon', { ascending: false });

        if (error) throw new Error(`Failed to fetch contracts: ${error.message}`);

        if (contractsData && contractsData.length > 0) {
            const contractsByCid = {};
            contractsData.forEach(contract => {
                if (!contractsByCid[contract.cid]) {
                    contractsByCid[contract.cid] = {
                        title: contract.title,
                        accountname: contract.accountname,
                        createdon: contract.createdon,
                        updatedon: contract.updatedon,
                        stage: contract.stage,
                        status: contract.status
                    };
                } else {
                    if (new Date(contract.updatedon) > new Date(contractsByCid[contract.cid].updatedon)) {
                        contractsByCid[contract.cid].updatedon = contract.updatedon;
                    }
                }
            });

            Object.entries(contractsByCid).forEach(([cid, contract], index) => {
                const row = document.createElement('tr');
                const statusBadgeClass = contract.status === 'In Progress' ? 'badge bg-label-warning' : 'badge bg-label-success';
                let actionDropdown = '';

                // Unique ID for each dropdown to avoid conflicts
                const dropdownId = `dropdownMenuButton_contract_${cid}_${index}`;

                if (contract.stage === 'Draft' && contract.status === 'In Progress') {
                    actionDropdown = `
                        <td class="action-dropdown">
                            <div class="dropdown">
                                <button class="btn btn-sm btn-icon" type="button" id="${dropdownId}" data-bs-toggle="dropdown" aria-expanded="false">
                                    <i class="bi bi-three-dots-vertical"></i>
                                </button>
                                <ul class="dropdown-menu" aria-labelledby="${dropdownId}">
                                    <li><a class="dropdown-item edit-btn" href="#" data-cid="${cid}">Edit</a></li>
                                    <li><a class="dropdown-item complete-btn" href="#" data-cid="${cid}">Mark as Completed</a></li>
                                    <li><a class="dropdown-item discard-btn" href="#" data-cid="${cid}">Discard</a></li>
                                    <li><a class="dropdown-item history-btn" href="#" data-cid="${cid}">History</a></li>
                                </ul>
                            </div>
                        </td>
                    `;
                } else if (contract.stage === 'Draft' && contract.status === 'Completed') {
                    actionDropdown = `
                        <td class="action-dropdown">
                            <div class="dropdown">
                                <button class="btn btn-sm btn-icon" type="button" id="${dropdownId}" data-bs-toggle="dropdown" aria-expanded="false">
                                    <i class="bi bi-three-dots-vertical"></i>
                                </button>
                                <ul class="dropdown-menu" aria-labelledby="${dropdownId}">
                                    <li><a class="dropdown-item start-journey-btn" href="#" data-cid="${cid}">Start Journey</a></li>
                                    <li><a class="dropdown-item discard-btn" href="#" data-cid="${cid}">Discard</a></li>
                                    <li><a class="dropdown-item history-btn" href="#" data-cid="${cid}">History</a></li>
                                </ul>
                            </div>
                        </td>
                    `;
                } else if (contract.status === 'In Progress' && contract.stage !== 'Draft') {
                    actionDropdown = `
                        <td class="action-dropdown">
                            <div class="dropdown">
                                <button class="btn btn-sm btn-icon" type="button" id="${dropdownId}" data-bs-toggle="dropdown" aria-expanded="false">
                                    <i class="bi bi-three-dots-vertical"></i>
                                </button>
                                <ul class="dropdown-menu" aria-labelledby="${dropdownId}">
                                    <li><a class="dropdown-item discard-btn" href="#" data-cid="${cid}">Discard</a></li>
                                    <li><a class="dropdown-item download-btn" href="#" data-cid="${cid}">Download</a></li>
                                    <li><a class="dropdown-item history-btn" href="#" data-cid="${cid}">History</a></li>
                                </ul>
                            </div>
                        </td>
                    `;
                }

                row.innerHTML = `
                    <td>${contract.title}</td>
                    <td>${contract.accountname}</td>
                    <td>${new Date(contract.createdon).toLocaleString()}</td>
                    <td>${new Date(contract.updatedon).toLocaleString()}</td>
                    <td>${contract.stage}</td>
                    <td><span class="${statusBadgeClass}">${contract.status}</span></td>
                    ${actionDropdown}
                `;
                tbody.appendChild(row);

                // Event Listeners
                if (contract.stage === 'Draft' && contract.status === 'In Progress') {
                    row.querySelector('.complete-btn')?.addEventListener('click', async (e) => {
                        e.preventDefault();
                        if (confirm(`Are you sure you want to mark contract ${contract.title} as completed?`)) {
                            await markContractAsCompleted(cid, contractsTableName);
                        }
                    });
                } else if (contract.stage === 'Draft' && contract.status === 'Completed') {
                    row.querySelector('.start-journey-btn')?.addEventListener('click', async (e) => {
                        e.preventDefault();
                        await startJourney(cid, contractsTableName);
                    });
                }

                row.querySelector('.edit-btn')?.addEventListener('click', (e) => {
                    e.preventDefault();
                    alert(`Edit functionality for contract ${cid} not yet implemented.`);
                });

                row.querySelector('.discard-btn')?.addEventListener('click', async (e) => {
                    e.preventDefault();
                    if (confirm(`Are you sure you want to discard contract ${contract.title}? This action cannot be undone.`)) {
                        await discardContract(cid, contractsTableName);
                    }
                });

                row.querySelector('.history-btn')?.addEventListener('click', (e) => {
                    e.preventDefault();
                    showContractHistory(cid, contractsTableName);
                });

                row.querySelector('.download-btn')?.addEventListener('click', async (e) => {
                    e.preventDefault();
                    const { data: contractData } = await supabaseClient
                        .from(contractsTableName)
                        .select('storage_path')
                        .eq('cid', cid)
                        .single();
                    if (contractData?.storage_path) {
                        downloadFile(contractData.storage_path, `${contract.title}.docx`);
                    }
                });
            });
        } else {
            tbody.innerHTML = '<tr><td colspan="7" class="text-center">No contracts in progress found.</td></tr>';
        }
    } catch (err) {
        console.error('Error populating contracts table:', err);
        tbody.innerHTML = `<tr><td colspan="7" class="text-center">Error loading contracts: ${err.message}</td></tr>`;
    }
}

// Mark Contract as Completed
async function markContractAsCompleted(cid, contractsTableName) {
    try {

        await ensureStoragePathPdfColumn(contractsTableName);

        // Convert .docx to .pdf and update storage_path_pdf
        await convertDocxToPdfAndUpdate(contractsTableName, cid);

        const { data: contractData, error: fetchError } = await supabaseClient
            .from(contractsTableName)
            .select('title')
            .eq('cid', cid)
            .limit(1)
            .single();

        if (fetchError) {
            throw new Error(`Failed to fetch contract title: ${fetchError.message}`);
        }

        const title = contractData?.title || 'Contract';

        const { error } = await supabaseClient
            .from(contractsTableName)
            .update({ status: 'Completed', updatedon: new Date().toISOString() })
            .eq('cid', cid);
        if (error) throw new Error(`Failed to mark contract as completed: ${error.message}`);
        console.log(`Contract ${cid} marked as completed`);

        console.log(`Contract ${cid} marked as completed with PDF generated`);
        alert(`Contract "${title}" marked as completed and PDF generated successfully!`);
    
        localStorage.setItem('openPdfAfterReload', JSON.stringify({ cid, contractsTableName }));
        logToStorage(`Stored cid ${cid} for PDF opening after reload`);
    } catch (err) {
        console.error('Error marking contract as completed:', err);
        alert(`Error: ${err.message}`);
    }
}

// Start Journey Function
// Start Journey Function
async function startJourney(cid, contractsTableName) {
    try {
        // Fetch all entries for the given cid, ordered by id
        const { data: contractSteps, error } = await supabaseClient
            .from(contractsTableName)
            .select('id, email, work, valid, sequence')
            .eq('cid', cid)
            .order('id', { ascending: true });

        if (error) throw new Error(`Failed to fetch contract steps: ${error.message}`);

        // Find the first step with valid = 'Pending'
        const nextStep = contractSteps.find(step => step.valid === 'Pending');
        if (!nextStep) {
            alert('No pending steps found for this contract.');
            return;
        }

        let newStage = '';
        let newStatus = 'In Progress';

        if (nextStep.email && nextStep.work === 'approval') {
            newStage = 'Under Review – External';
        } else if (nextStep.email && nextStep.work === 'signature') {
            newStage = 'Pending Signature – External';
        } else if (!nextStep.email && nextStep.work === 'approval') {
            newStage = 'Under Review – Internal';
        } else if (!nextStep.email && nextStep.work === 'signature') {
            newStage = 'Pending Signature – Internal';
        }

        // Update only the specific row with the matching id
        const { error: updateError } = await supabaseClient
            .from(contractsTableName)
            .update({ 
                stage: newStage, 
                status: newStatus, 
                updatedon: new Date().toISOString() 
            })
            .eq('id', nextStep.id); // Update only the row with this specific id

        if (updateError) throw new Error(`Failed to update contract step: ${updateError.message}`);

        console.log(`Started journey for contract ${cid}, step ${nextStep.id}. New stage: ${newStage}, New status: ${newStatus}`);
    } catch (err) {
        console.error('Error starting journey:', err);
        alert(`Error: ${err.message}`);
    }
}

// Discard Contract
async function discardContract(cid, contractsTableName) {
    try {
        const { error } = await supabaseClient
            .from(contractsTableName)
            .delete()
            .eq('cid', cid);
        if (error) throw new Error(`Failed to discard contract: ${error.message}`);
        console.log(`Contract ${cid} discarded`);
    } catch (err) {
        console.error('Error discarding contract:', err);
        alert(`Error: ${err.message}`);
    }
}

// Show Contract History (Modal)
async function showContractHistory(cid, contractsTableName) {
    const modalHtml = `
        <div class="modal fade" id="contractHistoryModal" tabindex="-1" aria-labelledby="contractHistoryModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="contractHistoryModalLabel">Contract History - CID: ${cid}</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="table-responsive">
                            <table class="table table-bordered table-hover">
                                <thead class="table-light">
                                    <tr>
                                        <th>Sequence</th>
                                        <th>Team</th>
                                        <th>Email</th>
                                        <th>Work</th>
                                        <th>Approved By</th>
                                        <th>Approved Email</th>
                                        <th>Signed By</th>
                                        <th>Signed Email</th>
                                        <th>Updated On</th>
                                    </tr>
                                </thead>
                                <tbody id="contractHistoryTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>
    `;

    // Remove existing modal if any
    const existingModal = document.getElementById('contractHistoryModal');
    if (existingModal) existingModal.remove();
    document.body.insertAdjacentHTML('beforeend', modalHtml);

    const tbody = document.getElementById('contractHistoryTableBody');
    try {
        const { data: historyData, error } = await supabaseClient
            .from(contractsTableName)
            .select('sequence, team, email, work, iapprovedby, approved_email, isignedby, signed_email, updatedon')
            .eq('cid', cid)
            .order('sequence', { ascending: true });

        if (error) throw new Error(`Failed to fetch contract history: ${error.message}`);

        if (historyData && historyData.length > 0) {
            historyData.forEach(entry => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${entry.sequence || '-'}</td>
                    <td>${entry.team || '-'}</td>
                    <td>${entry.email || '-'}</td>
                    <td>${entry.work || '-'}</td>
                    <td>${entry.iapprovedby || '-'}</td>
                    <td>${entry.approved_email || '-'}</td>
                    <td>${entry.isignedby || '-'}</td>
                    <td>${entry.signed_email || '-'}</td>
                    <td>${new Date(entry.updatedon).toLocaleString()}</td>
                `;
                tbody.appendChild(row);
            });
        } else {
            tbody.innerHTML = '<tr><td colspan="9" class="text-center">No history found for this contract.</td></tr>';
        }
    } catch (err) {
        console.error('Error fetching contract history:', err);
        tbody.innerHTML = `<tr><td colspan="9" class="text-center">Error: ${err.message}</td></tr>`;
    }

    const modal = new bootstrap.Modal(document.getElementById('contractHistoryModal'));
    modal.show();
}

    // TODO: Fetch and populate actual in-progress contracts from database

// Show Contracts Completed
async function showContractsCompleted(element) {
    const teamContent = document.getElementById('templatesContent');
    const menuItems = document.querySelectorAll('.menu-item');
    menuItems.forEach(item => item.classList.remove('active'));
    element.parentElement.classList.add('active');

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    if (!organisationName) {
        alert('No admin logged in. Please log in first.');
        window.location.href = 'login.html';
        return;
    }

    const contractsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;

    teamContent.innerHTML = `
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Completed Contracts</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-bordered table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>Agreement Title</th>
                                <th>Account Name</th>
                                <th>Created On</th>
                                <th>Updated On</th>
                                <th>Stage</th>
                                <th>Status</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="completedContractsTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    `;

    await populateCompletedContractsTable(contractsTableName);
}

async function populateCompletedContractsTable(contractsTableName) {
    const tbody = document.getElementById('completedContractsTableBody');
    tbody.innerHTML = '';

    try {
        const organisationName = localStorage.getItem('loggedInOrganisationName');
        console.log('Populating completed contracts table:', { 
            contractsTableName, 
            organisationName, 
            timestamp: new Date().toISOString() 
        });

        if (!organisationName) {
            console.error('No loggedInOrganisationName in localStorage');
            throw new Error('Organization name not found in localStorage');
        }

        // Fetch unique cids with specified stages
        const { data: contractsData, error } = await supabaseClient
            .from(contractsTableName)
            .select('cid, title, accountname, createdon, updatedon, stage, status, storage_path, storage_path_pdf, requested_by, requested_team')
            .in('stage', ['Completed', 'Cancellation Initiated to Finance Team', 'Cancellation Initiated to Legal Team', 'Contract Cancelled'])
            .order('updatedon', { ascending: false });

        if (error) {
            console.error('Supabase fetch error:', { error, table: contractsTableName });
            throw new Error(`Failed to fetch contracts: ${error.message}`);
        }

        console.log('Fetched contracts:', { count: contractsData.length, data: contractsData });

        // Use a Set to ensure unique cids
        const uniqueContracts = [];
        const seenCids = new Set();

        contractsData.forEach(contract => {
            if (!seenCids.has(contract.cid)) {
                seenCids.add(contract.cid);
                uniqueContracts.push(contract);
            }
        });

        console.log('Unique contracts:', { count: uniqueContracts.length, cids: [...seenCids] });

        if (uniqueContracts.length > 0) {
            uniqueContracts.forEach((contract, index) => {
                const row = document.createElement('tr');
                const isCancellationStage = ['Cancellation Initiated to Finance Team', 'Cancellation Initiated to Legal Team', 'Contract Cancelled'].includes(contract.stage);
                // Unique ID for each dropdown to avoid conflicts
                const dropdownId = `dropdownMenuButton_completed_${contract.cid}_${index}`;
                
                const actionDropdown = isCancellationStage ? `
                    <td class="action-dropdown">
                        <div class="dropdown">
                            <button class="btn btn-sm btn-icon" type="button" id="${dropdownId}" data-bs-toggle="dropdown" aria-expanded="false">
                                <i class="bi bi-three-dots-vertical"></i>
                            </button>
                            <ul class="dropdown-menu" aria-labelledby="${dropdownId}">
                                <li><a class="dropdown-item inform-parties-btn" href="#" 
                                       data-cid="${contract.cid}" 
                                       data-title="${contract.title}" 
                                       data-requested-by="${contract.requested_by}" 
                                       data-requested-team="${contract.requested_team}">Inform Parties</a></li>
                            </ul>
                        </div>
                    </td>
                ` : `
                    <td class="action-dropdown">
                        <div class="dropdown">
                            <button class="btn btn-sm btn-icon" type="button" id="${dropdownId}" data-bs-toggle="dropdown" aria-expanded="false">
                                <i class="bi bi-three-dots-vertical"></i>
                            </button>
                            <ul class="dropdown-menu" aria-labelledby="${dropdownId}">
                                <li><a class="dropdown-item download-btn" href="#" 
                                       data-storage-path="${contract.storage_path_pdf}" 
                                       data-cid="${contract.cid}">Download</a></li>
                                <li><a class="dropdown-item initiate-cancellation-btn" href="#" 
                                       data-cid="${contract.cid}" 
                                       data-title="${contract.title}" 
                                       data-requested-by="${contract.requested_by}" 
                                       data-requested-team="${contract.requested_team}">Initiate Cancellation</a></li>
                                <li><a class="dropdown-item extension-btn" href="#" 
                                       data-cid="${contract.cid}" 
                                       data-storage-path="${contract.storage_path}" 
                                       data-title="${contract.title}">Extension</a></li>
                            </ul>
                        </div>
                    </td>
                `;
                
                row.innerHTML = `
                    <td>${contract.title}</td>
                    <td>${contract.accountname}</td>
                    <td>${new Date(contract.createdon).toLocaleString()}</td>
                    <td>${new Date(contract.updatedon).toLocaleString()}</td>
                    <td>${contract.stage}</td>
                    <td>${contract.status}</td>
                    ${actionDropdown}
                `;
                tbody.appendChild(row);

                if (isCancellationStage) {
                    const informButton = row.querySelector('.inform-parties-btn');
                    if (informButton) {
                        console.log('Attaching event listener to Inform Parties button:', { 
                            cid: contract.cid, 
                            title: contract.title,
                            organisationName 
                        });
                        informButton.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('Inform Parties button clicked:', { 
                                cid: contract.cid, 
                                title: contract.title, 
                                organisationName,
                                timestamp: new Date().toISOString() 
                            });
                            informParties(
                                contract.cid, 
                                contract.title, 
                                contract.accountname, 
                                contract.requested_by, 
                                contract.requested_team, 
                                contractsTableName, 
                                organisationName
                            );
                        });
                    } else {
                        console.error('Inform Parties button not found in row:', { cid: contract.cid });
                    }
                } else {
                    const downloadButton = row.querySelector('.download-btn');
                    const cancelButton = row.querySelector('.initiate-cancellation-btn');
                    const extensionButton = row.querySelector('.extension-btn');

                    if (downloadButton) {
                        downloadButton.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('Download button clicked:', { 
                                cid: contract.cid, 
                                storage_path: contract.storage_path_pdf 
                            });
                            downloadFile(contract.storage_path_pdf, `${contract.cid}_${contract.title}.pdf`);
                        });
                    }
                    if (cancelButton) {
                        cancelButton.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('Initiate Cancellation button clicked:', { cid: contract.cid });
                            showCancellationPopup(
                                contract.cid, 
                                contract.title, 
                                contract.requested_by, 
                                contract.requested_team, 
                                contractsTableName
                            );
                        });
                    }
                    if (extensionButton) {
                        extensionButton.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('Extension button clicked:', { 
                                cid: contract.cid, 
                                storage_path: contract.storage_path,
                                title: contract.title 
                            });
                            openExtensionEditor(
                                contract.cid, 
                                contract.storage_path, 
                                contract.title, 
                                contractsTableName
                            );
                        });
                    }
                }
            });
        } else {
            console.log('No contracts found for table');
            tbody.innerHTML = '<tr><td colspan="7" class="text-center">No contracts found.</td></tr>';
        }
    } catch (err) {
        console.error('Error in populateCompletedContractsTable:', {
            message: err.message,
            stack: err.stack,
            table: contractsTableName
        });
        tbody.innerHTML = `<tr><td colspan="7" class="text-center">Error loading contracts: ${err.message}</td></tr>`;
    }
}

async function openExtensionEditor(cid, storagePath, title, contractsTableName) {
    const organisationName = localStorage.getItem('loggedInOrganisationName');
    const username = localStorage.getItem('loggedInAdminUsername');
    if (!organisationName || !username) {
        alert('Please log in first!');
        return;
    }

    const { data: orgData, error: orgError } = await supabaseClient
        .from('orgadmins')
        .select('org_code')
        .eq('organisation_name', organisationName)
        .single();
    if (orgError || !orgData) {
        alert('Error fetching organization code.');
        return;
    }
    const orgcode = orgData.org_code;

    const editorContainer = document.getElementById('fullScreenEditor');
    const templatesContent = document.getElementById('templatesContent');
    const editorButtons = document.getElementById('editorButtons');

    templatesContent.classList.add('hidden');
    editorContainer.style.display = 'block';

    const baseUrl = 'http://192.168.4.37:3000';
    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
    
    // Generate new filename with _v2 for DOCX
    const pathParts = storagePath.split('/');
    const originalFilename = pathParts.pop();
    const fileExtension = originalFilename.split('.').pop();
    const filenameWithoutExtension = originalFilename.replace(`.${fileExtension}`, '');
    const newFilename = `${filenameWithoutExtension}_v2.${fileExtension}`;
    const newStoragePath = `${pathParts.join('/')}/${newFilename}`.replace('//', '/');
    
    // Generate PDF filename with _v2 in the same directory
    const pdfFilename = `${filenameWithoutExtension}_v2.pdf`;
    const newStoragePathPdf = `${pathParts.join('/')}/${pdfFilename}`.replace('//', '/');
    
    const fileUrl = `${baseUrl}${storagePath}`;
    const callbackUrl = `${baseUrl}/sync-draft?tableName=${contractsTableName}&contractId=${cid}&contractTitle=${encodeURIComponent(title)}&orgcode=${orgcode}&username=${encodeURIComponent(username)}`;

    const config = {
        document: {
            fileType: 'docx',
            title: `${title}.docx`,
            url: fileUrl,
            key: `${cid}_${Date.now()}`,
            permissions: { edit: true, download: true }
        },
        documentType: 'word',
        editorConfig: {
            mode: 'edit',
            callbackUrl: callbackUrl,
            user: {
                id: username,
                name: username
            },
            customization: {
                features: {
                    trackChanges: true
                }
            },
            coediting: {
                mode: 'fast',
                change: true
            }
        },
        events: {
            onReady: () => console.log('Editor UI is ready'),
            onDocumentReady: () => console.log('Document is fully ready'),
            onError: (event) => console.error('Extension editor error:', event.data),
            onDocumentStateChange: (event) => {
                console.log('Extension document state changed:', event.data);
                if (event.data && event.data.saved) {
                    console.log('Extension document changes saved');
                }
            },
            onCollaborativeChanges: () => console.log('Extension collaborative changes detected'),
            onInfo: (event) => console.log('Extension editor info:', event.data)
        },
        height: '100%',
        width: '100%'
    };

    const token = jwt.sign(config, jwtSecret);
    config.token = token;

    if (createEditor) {
        console.log('Destroying existing editor');
        createEditor.destroyEditor();
    }

    console.log('Initializing new editor with config:', config);
    createEditor = new DocsAPI.DocEditor('editorWrapper', config);
    console.log('ONLYOFFICE editor opened for extension:', { createEditor: !!createEditor });

    editorButtons.innerHTML = `
        <button id="editorSaveBtn" class="btn btn-primary">Save</button>
    `;

    const saveButton = document.getElementById('editorSaveBtn');
    if (!saveButton) {
        console.error('Save button not found in DOM');
        alert('Error: Save button not initialized.');
        return;
    }

    saveButton.addEventListener('click', async () => {
        console.log('Save button clicked:', { cid, storagePath, newStoragePath, newStoragePathPdf });

        try {
            console.log('Editor state:', {
                isDefined: !!createEditor,
                methods: createEditor ? Object.keys(createEditor) : null,
                executeMethodAvailable: createEditor && typeof createEditor.executeMethod === 'function'
            });

            console.log('Waiting for server to process any pending changes');
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Save DOCX to newStoragePath
            console.log('Calling /save-as endpoint for DOCX:', { newStoragePath });
            const saveAsUrl = `${baseUrl}/save-as?newPath=${encodeURIComponent(newStoragePath)}`;
            const response = await fetch(saveAsUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${jwt.sign({ path: newStoragePath }, jwtSecret)}`
                },
                body: JSON.stringify({
                    url: `${baseUrl}${storagePath}`,
                    title: `${title}_v2.docx`
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.error('DOCX save error:', errorData);
                throw new Error(`Failed to save DOCX document: ${errorData.message || response.statusText}`);
            }

            const saveResult = await response.json();
            if (saveResult.error !== 0) {
                console.error('DOCX save failed:', saveResult.message);
                throw new Error(`DOCX save failed: ${saveResult.message}`);
            }

            console.log('DOCX document saved:', saveResult.storagePath);

            // Convert DOCX to PDF using existing /convert-to-pdf endpoint
            console.log('Calling /convert-to-pdf endpoint:', { docxPath: saveResult.storagePath });
            const convertToPdfUrl = `${baseUrl}/convert-to-pdf`;
            const pdfResponse = await fetch(convertToPdfUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${jwt.sign({ path: saveResult.storagePath }, jwtSecret)}`
                },
                body: JSON.stringify({
                    docxPath: saveResult.storagePath
                })
            });

            if (!pdfResponse.ok) {
                const errorData = await pdfResponse.json();
                console.error('PDF conversion error:', errorData);
                throw new Error(`Failed to convert to PDF: ${errorData.details || pdfResponse.statusText}`);
            }

            const pdfResult = await pdfResponse.json();
            if (pdfResult.error) {
                console.error('PDF conversion failed:', pdfResult.details);
                throw new Error(`PDF conversion failed: ${pdfResult.details}`);
            }

            console.log('PDF document saved:', pdfResult.pdfPath);

            // Update database with new_storage_path and new_storage_path_pdf
            console.log('Updating database with new_storage_path and new_storage_path_pdf:', {
                newStoragePath: saveResult.storagePath,
                newStoragePathPdf: pdfResult.pdfPath
            });
            const { error: updateError } = await supabaseClient
                .from(contractsTableName)
                .update({
                    new_storage_path: saveResult.storagePath,
                    new_storage_path_pdf: pdfResult.pdfPath
                })
                .eq('cid', cid);

            if (updateError) {
                console.error('Failed to update database:', updateError);
                throw new Error('Error saving document paths to database.');
            }

            console.log('Database updated:', {
                cid,
                newStoragePath: saveResult.storagePath,
                newStoragePathPdf: pdfResult.pdfPath
            });

            console.log('Updating stage, status, and valid:', { stage: 'Extension Draft', status: 'Extension In Progress', valid: 'Pending' });
            const { error: statusError } = await supabaseClient
                .from(contractsTableName)
                .update({
                    stage: 'Extension Draft',
                    status: 'Extension In Progress',
                    valid: 'Pending'
                })
                .eq('cid', cid);

            if (statusError) {
                console.error('Failed to update stage, status, and valid:', statusError);
                throw new Error('Error updating contract stage, status, and valid.');
            }

            console.log('Updated stage, status, and valid:', { cid, stage: 'Extension Draft', status: 'Extension In Progress', valid: 'Pending' });

            console.log('Fetching first row for cid:', { cid });
            const { data: firstRow, error: fetchError } = await supabaseClient
                .from(contractsTableName)
                .select('id, work, email')
                .eq('cid', cid)
                .order('id', { ascending: true })
                .limit(1)
                .single();

            if (fetchError || !firstRow) {
                console.error('Failed to fetch first row for cid:', fetchError || 'No row found', { cid });
                throw new Error('Error fetching contract details for stage update.');
            }

            console.log('Fetched first row:', { id: firstRow.id, work: firstRow.work, email: firstRow.email });

            let newStage;
            if (firstRow.work === 'approval') {
                newStage = firstRow.email ? 'Extension Draft – External Approval' : 'Extension Draft – Internal Approval';
            } else if (firstRow.work === 'signature') {
                newStage = firstRow.email ? 'Extension Draft – External Signature' : 'Extension Draft – Internal Signature';
            } else {
                console.warn('Unexpected work value:', firstRow.work);
                throw new Error('Invalid work value in contract row.');
            }

            console.log('Updating stage for row:', { id: firstRow.id, newStage });
            const { error: stageUpdateError } = await supabaseClient
                .from(contractsTableName)
                .update({ stage: newStage })
                .eq('id', firstRow.id);

            if (stageUpdateError) {
                console.error('Failed to update stage for row:', stageUpdateError, { id: firstRow.id, newStage });
                throw new Error('Error updating contract stage for specific row.');
            }

            console.log('Updated stage for row:', { id: firstRow.id, newStage });

            // Send email for "Extension Draft – External Approval"
            if (newStage === 'Extension Draft – External Approval' && firstRow.email) {
                console.log('Sending external review email:', { email: firstRow.email, contractId: firstRow.id, contractsTableName });
                const reviewUrl = `${baseUrl}/external-extension.html?email=${encodeURIComponent(firstRow.email)}&contractId=${encodeURIComponent(firstRow.id)}&table=${encodeURIComponent(contractsTableName)}`;
                try {
                    const response = await fetch(`${baseUrl}/send-external-review-email`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            toEmail: firstRow.email,
                            reviewUrl: reviewUrl
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Server error: ${errorData.error || 'Unknown error'} - Details: ${errorData.details || 'No details'}`);
                    }

                    console.log('External review email sent to:', firstRow.email);
                } catch (error) {
                    console.error('Error sending external review email:', error);
                    throw new Error('Error sending approval email.');
                }
            }

            // Close the editor
            if (createEditor) {
                console.log('Destroying editor');
                createEditor.destroyEditor();
            }
            editorContainer.style.display = 'none';
            templatesContent.classList.remove('hidden');
            showContractsCompleted(document.getElementById('contractsCompletedLink'));
        } catch (err) {
            console.error('Error during save:', err);
            alert('Error processing document: ' + err.message);
        }
    });
}
async function informParties(cid, title, accountname, requested_by, requested_team, contractsTableName, organisationName) {
    console.log('Starting informParties:', {
        cid,
        title,
        accountname,
        requested_by,
        requested_team,
        contractsTableName,
        organisationName,
        timestamp: new Date().toISOString()
    });

    try {
        // Validate inputs
        if (!cid || !title || !accountname || !contractsTableName || !organisationName) {
            console.error('Missing required parameters:', { 
                cid, 
                title, 
                accountname, 
                contractsTableName, 
                organisationName 
            });
            throw new Error('Missing required parameters');
        }

        // Verify Supabase client
        if (!supabaseClient) {
            console.error('Supabase client not initialized');
            throw new Error('Supabase client not initialized');
        }

        // Verify localStorage values
        const loggedInUserUsername = localStorage.getItem('loggedInAdminUsername');
        console.log('localStorage values:', { 
            loggedInOrganisationName: organisationName, 
            loggedInAdminUsername: loggedInUserUsername 
        });

        if (!loggedInUserUsername) {
            console.error('No loggedInAdminUsername in localStorage');
            throw new Error('User not logged in');
        }

        // Step 1: Get ac_code from <organization_name>_accounts
        const accountsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_accounts`;
        console.log('Fetching ac_code from:', accountsTableName, 'for account:', accountname);
        const { data: accountData, error: accountError } = await supabaseClient
            .from(accountsTableName)
            .select('ac_code')
            .eq('name', accountname)
            .single();

        if (accountError || !accountData) {
            console.error('Account fetch error:', { error: accountError?.message, accountname });
            throw new Error(`Failed to fetch ac_code: ${accountError?.message || 'No matching account found'}`);
        }

        const acCode = accountData.ac_code;
        const acCodeLastSix = acCode.slice(-6);
        console.log('Fetched ac_code:', { acCode, acCodeLastSix });

        // Step 2: Get emails from <organization_name>_contacts
        const contactsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contacts`;
        console.log('Fetching contact emails from:', contactsTableName, 'with contact_code like:', `${acCodeLastSix}%`);
        const { data: contactsData, error: contactsError } = await supabaseClient
            .from(contactsTableName)
            .select('email')
            .ilike('contact_code', `${acCodeLastSix}%`);

        if (contactsError || !contactsData || contactsData.length === 0) {
            console.error('Contacts fetch error:', { error: contactsError?.message, contact_code: `${acCodeLastSix}%` });
            throw new Error(`Failed to fetch contact emails: ${contactsError?.message || 'No matching contacts found'}`);
        }

        const toEmails = contactsData.map(contact => contact.email);
        console.log('Contact emails fetched:', toEmails);

        // Step 3: Get subject, body, storage_path from <organization_name>_contractcancellation
        const cancelledContractsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contractcancellation`;
        console.log('Fetching cancellation details from:', cancelledContractsTableName, 'for cid:', cid);
        const { data: cancellationData, error: cancellationError } = await supabaseClient
            .from(cancelledContractsTableName)
            .select('subject, body, storage_path')
            .eq('cid', cid)
            .not('subject', 'is', null)
            .not('body', 'is', null)
            .not('storage_path', 'is', null)
            .single();

        if (cancellationError || !cancellationData) {
            console.error('Cancellation data fetch error:', { error: cancellationError?.message, cid });
            throw new Error(`Failed to fetch cancellation details: ${cancellationError?.message || 'No matching cancellation data found'}`);
        }

        const { subject, body, storage_path } = cancellationData;
        console.log('Cancellation details:', { subject, bodyLength: body?.length, storage_path });

        // Step 4: Get logged-in user's email from users table
        console.log('Fetching user email for username:', loggedInUserUsername);
        const { data: userData, error: userError } = await supabaseClient
            .from('users')
            .select('email')
            .eq('username', loggedInUserUsername)
            .single();

        if (userError || !userData) {
            console.error('User email fetch error:', { error: userError?.message, username: loggedInUserUsername });
            throw new Error(`Failed to fetch user email: ${userError?.message || 'No matching user found'}`);
        }

        const ccEmail = userData.email;
        console.log('Logged-in user email:', ccEmail);

        // Step 5: Send email via server endpoint
        const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
        console.log('Generating JWT token');
        const token = jwt.sign({ cid, organisationName }, jwtSecret);
        console.log('JWT token generated:', token.slice(0, 20) + '...');

        const payload = {
            to: toEmails,
            cc: [ccEmail],
            subject,
            body,
            storagePath: storage_path,
            organisationName
        };
        console.log('Sending email request:', {
            endpoint: 'http://192.168.4.37:3000/send-cancellation-email',
            payload: { ...payload, bodyLength: body?.length },
            headers: { Authorization: `Bearer ${token.slice(0, 20)}...` }
        });

        const response = await fetch('http://192.168.4.37:3000/send-cancellation-email', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });

        console.log('Fetch response:', {
            status: response.status,
            statusText: response.statusText,
            ok: response.ok
        });

        const result = await response.json();
        console.log('Server response:', result);

        if (!response.ok) {
            console.error('Email request failed:', {
                status: response.status,
                statusText: response.statusText,
                result
            });
            throw new Error(`Failed to send email: ${response.status} - ${result.message || response.statusText}`);
        }

        if (result.error === 0) {
            console.log('Email sent successfully:', { messageId: result.messageId });
            alert('Email sent successfully to parties.');
        } else {
            console.error('Server reported error:', result);
            throw new Error(`Server error: ${result.message}`);
        }
    } catch (err) {
        console.error('Error in informParties:', {
            message: err.message,
            stack: err.stack,
            cid,
            timestamp: new Date().toISOString()
        });
        alert(`Error: Failed to inform parties - ${err.message}`);
    }
}
async function createCancellationTableIfNotExists(orgName) {
    const tableName = `${orgName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contractcancellation`;
    console.log(`Checking if table ${tableName} exists...`);
    const { data: tableExists, error: checkError } = await supabaseClient
        .rpc('check_contacts_table_exists', { table_name: tableName });
    if (checkError) {
        console.error('Table existence check failed:', checkError);
        throw new Error(`Error checking table existence: ${checkError.message}`);
    }
    if (!tableExists) {
        console.log(`Table ${tableName} does not exist. Creating...`);
        const { error: createError } = await supabaseClient.rpc('run_contacts_sql', {
            sql_statement: `
                CREATE TABLE ${tableName} (
                    id SERIAL PRIMARY KEY,
                    cid TEXT NOT NULL,
                    contracttitle TEXT NOT NULL,
                    requested_by TEXT NOT NULL,
                    requested_team TEXT NOT NULL,
                    initiator_name TEXT NOT NULL,
                    initiator_team TEXT NOT NULL,
                    remark TEXT,
                    subject TEXT,
                    body TEXT,
                    storage_path TEXT,
                    timestamp TIMESTAMP DEFAULT NOW()
                );
            `
        });
        if (createError) {
            console.error('Table creation failed:', createError);
            throw new Error(`Failed to create table ${tableName}: ${createError.message}`);
        }
        console.log(`Table ${tableName} created successfully.`);
    } else {
        console.log(`Table ${tableName} already exists.`);
    }
    return tableName;
}
async function showCancellationPopup(cid, contractTitle, requestedBy, requestedTeam, contractsTableName) {
    // Create popup modal
    const modal = document.createElement('div');
    modal.className = 'modal fade';
    modal.id = 'cancellationModal';
    modal.innerHTML = `
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Initiate Cancellation</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <h6>Cancellation Terms</h6>
                    <p id="terminationConditions">Loading...</p>
                    <div class="mb-3">
                        <label for="cancellationRemarks" class="form-label">Remarks</label>
                        <textarea class="form-control" id="cancellationRemarks" rows="4"></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="historyBtn">History</button>
                    <button type="button" class="btn btn-primary" id="submitCancellationBtn">Submit</button>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);

    // Initialize Bootstrap modal
    const bootstrapModal = new bootstrap.Modal(modal);
    bootstrapModal.show();

    try {
        // Fetch termination conditions
        const organizationName = contractsTableName.replace('_contracts', ''); // Extract organization name
        const metadataTable = `${organizationName}_metadatacontract`;
        const { data: metadata, error: metadataError } = await supabaseClient
            .from(metadataTable)
            .select('terminationconditions')
            .eq('cid', cid)
            .single();

        if (metadataError) throw new Error(`Failed to fetch termination conditions: ${metadataError.message}`);

        document.getElementById('terminationConditions').textContent = metadata.terminationconditions || 'No termination conditions specified.';

        // Handle submit button
        document.getElementById('submitCancellationBtn').addEventListener('click', async () => {
            const remarks = document.getElementById('cancellationRemarks').value.trim();
            if (!remarks) {
                alert('Please provide remarks for cancellation.');
                return;
            }

            try {
                // Fetch initiator details from users table
                const loggedInUsername = localStorage.getItem('loggedInAdminUsername');
                const { data: userData, error: userError } = await supabaseClient
                    .from('users')
                    .select('name, team_type')
                    .eq('username', loggedInUsername)
                    .single();

                if (userError) throw new Error(`Failed to fetch user details: ${userError.message}`);

                // Create cancellation table if it doesn't exist
                const cancellationTable = await createCancellationTableIfNotExists(organizationName);

                // Update contracts table
                const { error: updateError } = await supabaseClient
                    .from(contractsTableName)
                    .update({
                        stage: 'Cancellation Initiated to Finance Team',
                        status: 'Cancellation Initiated to Finance Team',
                        updatedon: new Date().toISOString()
                    })
                    .eq('cid', cid);

                if (updateError) throw new Error(`Failed to update contract status: ${updateError.message}`);

                // Insert into cancellation table
                const { error: insertError } = await supabaseClient
                    .from(cancellationTable)
                    .insert({
                        cid: cid,
                        contracttitle: contractTitle,
                        requested_by: requestedBy,
                        requested_team: requestedTeam,
                        initiator_name: userData.name,
                        initiator_team: userData.team_type,
                        remark: remarks,
                        subject: null,
                        body: null,
                        storage_path: null,
                        timestamp: new Date().toISOString()
                    });

                if (insertError) throw new Error(`Failed to insert cancellation record: ${insertError.message}`);

                alert('Cancellation initiated successfully.');
                bootstrapModal.hide();
                // Refresh the completed contracts table
                await showContractsCompleted(document.getElementById('contractsCompletedLink'));
            } catch (err) {
                console.error('Error processing cancellation:', err);
                alert(`Error: ${err.message}`);
            }
        });

        // Handle history button
        document.getElementById('historyBtn').addEventListener('click', async () => {
            // Create history modal
            const historyModal = document.createElement('div');
            historyModal.className = 'modal fade';
            historyModal.id = 'historyModal';
            historyModal.innerHTML = `
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Cancellation History</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <table class="table table-striped">
                                <thead>
                                    <tr>
                                        <th>Initiator Name</th>
                                        <th>Initiator Team</th>
                                        <th>Remarks</th>
                                    </tr>
                                </thead>
                                <tbody id="historyTableBody">
                                    <tr><td colspan="3">Loading...</td></tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(historyModal);

            // Initialize Bootstrap history modal
            const bootstrapHistoryModal = new bootstrap.Modal(historyModal);
            bootstrapHistoryModal.show();

            try {
                // Fetch cancellation history
                const cancellationTable = `${organizationName}_contractcancellation`;
                const { data: historyData, error: historyError } = await supabaseClient
                    .from(cancellationTable)
                    .select('initiator_name, initiator_team, remark')
                    .eq('cid', cid);

                if (historyError) throw new Error(`Failed to fetch cancellation history: ${historyError.message}`);

                const historyTableBody = document.getElementById('historyTableBody');
                historyTableBody.innerHTML = ''; // Clear loading message

                if (historyData.length === 0) {
                    historyTableBody.innerHTML = '<tr><td colspan="3">No cancellation history found.</td></tr>';
                } else {
                    historyData.forEach(row => {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `
                            <td>${row.initiator_name || '-'}</td>
                            <td>${row.initiator_team || '-'}</td>
                            <td>${row.remark || '-'}</td>
                        `;
                        historyTableBody.appendChild(tr);
                    });
                }

                // Cleanup history modal on hide
                historyModal.addEventListener('hidden.bs.modal', () => {
                    historyModal.remove();
                });
            } catch (err) {
                console.error('Error loading cancellation history:', err);
                document.getElementById('historyTableBody').innerHTML = `<tr><td colspan="3">Error: ${err.message}</td></tr>`;
            }
        });

        // Cleanup modal on hide
        modal.addEventListener('hidden.bs.modal', () => {
            modal.remove();
        });
    } catch (err) {
        console.error('Error loading cancellation popup:', err);
        document.getElementById('terminationConditions').textContent = `Error: ${err.message}`;
    }
}


async function openCreateContractModal(orgName) {
    const existingModal = document.getElementById('createContractModal');
    if (existingModal) existingModal.remove();

    const modalHtml = `
        <div class="modal fade" id="createContractModal" tabindex="-1" aria-labelledby="createContractModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="createContractModalLabel">Create New Contract</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body" id="createContractModalBody">
                        <div id="stage1">
                            <div class="mb-3">
                                <label for="workflowSelect" class="form-label">Select Workflow</label>
                                <select class="form-select" id="workflowSelect">
                                    <option value="">Select Workflow</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label for="contractTitle" class="form-label">Contract Title</label>
                                <input type="text" class="form-control" id="contractTitle" placeholder="Enter contract title" required>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Contract Type</label>
                                <div class="d-flex align-items-center">
                                    <div class="form-check me-3">
                                        <input class="form-check-input" type="radio" name="contractType" id="startBlank" value="blank" checked>
                                        <label class="form-check-label" for="startBlank">Start Blank</label>
                                    </div>
                                    <div class="form-check me-3">
                                        <input class="form-check-input" type="radio" name="contractType" id="useTemplate" value="template">
                                        <label class="form-check-label" for="useTemplate">Use Template</label>
                                    </div>
                                    <select class="form-select d-none" id="templateSelect">
                                        <option value="">Select Template</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div id="stage2" class="d-none">
                            <div class="mb-3">
                                <label for="accountSelect" class="form-label">Select Account</label>
                                <select class="form-select" id="accountSelect">
                                    <option value="">Select Account</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label for="accountSignatureSelect" class="form-label">Account Signature</label>
                                <select class="form-select" id="accountSignatureSelect">
                                    <option value="">Select Signature</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label for="contractReceiverSelect" class="form-label">Contract Receiver</label>
                                <select class="form-select" id="contractReceiverSelect">
                                    <option value="">Select Receiver</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="nextBtn">Next</button>
                        <button type="button" class="btn btn-primary d-none" id="saveBtn">Save</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);

    const modal = new bootstrap.Modal(document.getElementById('createContractModal'));
    modal.show();

    // Populate Workflow Select
    const workflowTableName = `${orgName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_workflow`;
    const workflowSelect = document.getElementById('workflowSelect');
    try {
        const { data: workflows, error } = await supabaseClient
            .from(workflowTableName)
            .select('workflow_name');
        if (error && error.code !== '42P01') throw error;
        if (workflows) {
            workflows.forEach(workflow => {
                workflowSelect.innerHTML += `<option value="${workflow.workflow_name}">${workflow.workflow_name}</option>`;
            });
        }
    } catch (err) {
        console.error('Error fetching workflows:', err);
    }

    // Toggle Template Select visibility
    const startBlankRadio = document.getElementById('startBlank');
    const useTemplateRadio = document.getElementById('useTemplate');
    const templateSelect = document.getElementById('templateSelect');
    useTemplateRadio.addEventListener('change', () => {
        templateSelect.classList.toggle('d-none', !useTemplateRadio.checked);
        if (useTemplateRadio.checked) populateTemplateSelect(orgName);
    });
    startBlankRadio.addEventListener('change', () => {
        templateSelect.classList.add('d-none');
    });

    // Next Button Logic
    document.getElementById('nextBtn').addEventListener('click', () => {
        const workflow = workflowSelect.value;
        const title = document.getElementById('contractTitle').value.trim();
        if (!workflow || !title) {
            alert('Please select a workflow and enter a contract title.');
            return;
        }
        document.getElementById('stage1').classList.add('d-none');
        document.getElementById('stage2').classList.remove('d-none');
        document.getElementById('nextBtn').classList.add('d-none');
        document.getElementById('saveBtn').classList.remove('d-none');
        populateAccountSelect(orgName);
    });

    // Save Button Logic
    // Save Button Logic
    document.getElementById('saveBtn').addEventListener('click', async () => {
    const workflowName = workflowSelect.value;
    const title = document.getElementById('contractTitle').value.trim();
    const account = document.getElementById('accountSelect').value;
    const signature = document.getElementById('accountSignatureSelect').value;
    const receiver = document.getElementById('contractReceiverSelect').value;
    const templateType = document.querySelector('input[name="contractType"]:checked').value;
    const templateName = templateType === 'template' ? templateSelect.value : null;

    if (!workflowName || !title || !account || !signature || !receiver) {
        alert('Please fill all required fields.');
        return;
    }

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    const contractsTableName = `${organisationName.replace(/\s+/g, '_')}_contracts`; // Adjusted for acme_corp_contracts
    await createContractsTableIfNotExists(contractsTableName);

    const { data: orgData, error: orgError } = await supabaseClient
        .from('orgadmins')
        .select('org_code')
        .eq('organisation_name', organisationName)
        .single();
    if (orgError || !orgData) {
        console.error('Error fetching org_code:', orgError);
        alert('Error fetching organization details.');
        return;
    }
    const orgcode = orgData.org_code;

    const loggedInUsername = localStorage.getItem('loggedInAdminUsername');
    let requestedBy;
    let requestedTeam; // Declare requestedBy here to ensure it's always defined
    const { data: userData, error: userError } = await supabaseClient
        .from('users')
        .select('name,team_type')
        .eq('username', loggedInUsername)
        .single();
    if (userError || !userData) {
        console.error('Error fetching user name:', userError);
        alert('Error fetching user details.');
        return;
    } else {
        requestedBy = userData.name;
        requestedTeam = userData.team_type; // Assign value only if fetch is successful
    }

    const workflowTableName = `${organisationName.replace(/\s+/g, '_')}_workflow`; // Adjusted for acme_corp_workflow
    const { data: workflowData, error: workflowError } = await supabaseClient
        .from(workflowTableName)
        .select('wid, internal_approval, external_approval, internal_signature, external_signature')
        .eq('workflow_name', workflowName)
        .single();
    if (workflowError) {
        console.error('Error fetching workflow:', workflowError);
        alert(`Failed to fetch workflow: ${workflowError.message}`);
        return;
    }
    const wid = workflowData.wid;

    let storagePath = null;
    let fileUrl = null;
    const baseUrl = 'http://192.168.4.37:3000';
    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';

    if (templateType === 'template' && templateName) {
        const templateTableName = `${organisationName.replace(/\s+/g, '_')}_templates`; // Adjusted for acme_corp_templates
        const { data: templateData, error: templateError } = await supabaseClient
            .from(templateTableName)
            .select('storage_path')
            .eq('template_name', templateName)
            .eq('status', 'published')
            .order('last_updated_on', { ascending: false })
            .limit(1)
            .single();
        if (templateError || !templateData) {
            console.error('Error fetching template:', templateError);
            alert(`Failed to fetch template: ${templateError?.message || 'No published template found'}`);
            return;
        }
        storagePath = templateData.storage_path;
        fileUrl = `${baseUrl}${storagePath}`;
    } else {
        fileUrl = `${baseUrl}/test.docx`;
    }

    const cid = `cid_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const username = localStorage.getItem('loggedInAdminUsername');
    const newStoragePath = `/${orgcode}/contracts/${username}/${cid}_${title}.docx`;

    const steps = [];
    const workflowDetailsTableName = `${organisationName.replace(/\s+/g, '_')}_workflowdetails`; // Adjusted for acme_corp_workflowdetails
    const approvals = [
        { key: 'internal_approval', value: workflowData.internal_approval, type: 'approval' },
        { key: 'external_approval', value: workflowData.external_approval, type: 'approval' },
        { key: 'internal_signature', value: workflowData.internal_signature, type: 'signature' },
        { key: 'external_signature', value: workflowData.external_signature, type: 'signature' }
    ].filter(step => step.value !== 'disable')
     .sort((a, b) => parseInt(a.value.split('_')[1]) - parseInt(b.value.split('_')[1]));

    for (const step of approvals) {
        const stepNum = parseInt(step.value.split('_')[1]);
        if (step.key === 'internal_approval') {
            const { data: details, error } = await supabaseClient
                .from(workflowDetailsTableName)
                .select('sequence, team, approved_by, approved_team_member')
                .eq('wid', wid)
                .not('approved_by', 'is', null);
            if (error) throw new Error(`Failed to fetch workflow details: ${error.message}`);
            details.forEach(detail => {
                steps.push({
                    sequence: parseInt(`${stepNum}${detail.sequence}`),
                    team: detail.team,
                    email: null,
                    work: 'approval',
                    iapprovedby: detail.approved_by,
                    approved_email: detail.approved_by === 'Specific Team Member' ? detail.approved_team_member : null,
                    isignedby: null,
                    signed_email: null
                });
            });
        } else if (step.key === 'external_approval') {
            steps.push({
                sequence: stepNum,
                team: null,
                email: receiver,
                work: 'approval',
                iapprovedby: null,
                approved_email: null,
                isignedby: null,
                signed_email: null
            });
        } else if (step.key === 'internal_signature') {
            const { data: detail, error } = await supabaseClient
                .from(workflowDetailsTableName)
                .select('team, signed_by, signed_team_member')
                .eq('wid', wid)
                .not('signed_by', 'is', null)
                .single();
            if (error) throw new Error(`Failed to fetch workflow details: ${error.message}`);
            steps.push({
                sequence: stepNum,
                team: detail.team,
                email: null,
                work: 'signature',
                iapprovedby: null,
                approved_email: null,
                isignedby: detail.signed_by,
                signed_email: detail.signed_by === 'Specific Team Member' ? detail.signed_team_member : null
            });
        } else if (step.key === 'external_signature') {
            steps.push({
                sequence: stepNum,
                team: null,
                email: signature,
                work: 'signature',
                iapprovedby: null,
                approved_email: null,
                isignedby: null,
                signed_email: null
            });
        }
    }

    const now = new Date().toISOString();
    const contractData = steps.map(step => ({
        cid,
        title,
        accountname: account,
        createdon: now,
        updatedon: now,
        stage: 'Draft',
        status: 'In Progress',
        wid,
        template: templateType,
        storage_path: newStoragePath,
        valid: 'Pending',
        sequence: step.sequence,
        team: step.team,
        email: step.email,
        work: step.work,
        iapprovedby: step.iapprovedby,
        approved_email: step.approved_email,
        isignedby: step.isignedby,
        signed_email: step.signed_email,
        requested_by: requestedBy,
        requested_team: requestedTeam,
        new_storage_path:null
    }));

    try {
        const { error } = await supabaseClient
            .from(contractsTableName)
            .insert(contractData);
        if (error) throw new Error(`Failed to save contract: ${error.message}`);
        console.log('Contract saved successfully:', contractData);

        modal.hide();

        const editorContainer = document.getElementById('fullScreenEditor');
        const templatesContent = document.getElementById('templatesContent');
        const editorButtons = document.getElementById('editorButtons');

        templatesContent.classList.add('hidden');
        editorContainer.style.display = 'block';

        const callbackUrl = `${baseUrl}/save-contract?tableName=${contractsTableName}&contractId=${cid}&contractTitle=${encodeURIComponent(title)}&orgcode=${orgcode}&username=${encodeURIComponent(username)}`;
        const config = {
            document: {
                fileType: 'docx',
                title: `${title}.docx`,
                url: fileUrl,
                key: `${cid}_${Date.now()}`,
                permissions: { edit: true, download: true }
            },
            documentType: 'word',
            editorConfig: {
                mode: 'edit',
                callbackUrl: callbackUrl,
                user: { id: username, name: username },
                lang: 'en'
            },
            events: {
                onReady: () => console.log('Editor is ready'),
                onError: (event) => console.error('Editor error:', event.data),
                onDocumentStateChange: (event) => {
                    console.log('Document state changed:', event.data);
                    if (event.data && event.data.saved) {
                        if (createEditor) createEditor.destroyEditor();
                        editorContainer.style.display = 'none';
                        templatesContent.classList.remove('hidden');
                        showContractsInProgress(document.getElementById('contractsInProgressLink'));
                    }
                },
                onRequestSaveAs: (event) => console.log('Save as requested:', event.data)
            },
            height: '100%',
            width: '100%'
        };
        const token = jwt.sign(config, jwtSecret);
        config.token = token;

        if (createEditor) {
            createEditor.destroyEditor();
        }

        editorButtons.innerHTML = `
            <button id="editorCancelBtn" class="btn btn-secondary">Cancel</button>
            <button id="editorSaveBtn" class="btn btn-primary">Save</button>
            <button id="inviteCoEditorBtn" class="btn btn-info">Invite Co-Editor</button>
            <button id="historyBtn" class="btn btn-warning">History</button>
            <button id="chatBtn" class="btn btn-success">Chat</button>
        `;

        createEditor = new DocsAPI.DocEditor('editorWrapper', config);
        console.log('ONLYOFFICE editor opened successfully');

        document.getElementById('editorCancelBtn').onclick = () => {
            if (createEditor) createEditor.destroyEditor();
            editorContainer.style.display = 'none';
            templatesContent.classList.remove('hidden');
            showContractsInProgress(document.getElementById('contractsInProgressLink'));
        };

        document.getElementById('editorSaveBtn').onclick = () => {
            console.log('Save button clicked, handled by ONLYOFFICE callback');
            console.log('Save button clicked');
        if (createEditor) {
        setTimeout(() => { // Give some time for the save to process
            createEditor.destroyEditor();
            editorContainer.style.display = 'none';
            templatesContent.classList.remove('hidden');
            showContractsInProgress(document.getElementById('contractsInProgressLink'));
        }, 1000); // Adjust delay as needed based on save time
    }
        };

        document.getElementById('inviteCoEditorBtn').onclick = () => {
            openInviteCoEditorModal(cid, organisationName);
        };

        document.getElementById('historyBtn').onclick = () => {
            alert('History feature not implemented yet.');
        };

        document.getElementById('chatBtn').onclick = () => {
            alert('Chat feature not implemented yet.');
        };

    } catch (err) {
        console.error('Error saving contract:', err);
        alert(`Error: ${err.message}`);
    }
});
}

// Function to open the Invite Co-Editor modal
// Function to open the Invite Co-Editor modal
async function openInviteCoEditorModal(cid, organisationName) {
    const teamsTableName = `${organisationName.replace(/\s+/g, '_')}_teams`;
    const modalHtml = `
        <div class="modal fade" id="inviteCoEditorModal" tabindex="-1" aria-labelledby="inviteCoEditorModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="inviteCoEditorModalLabel">Invite Co-Editor</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div id="coEditorEntries">
                            <div class="co-editor-entry row mb-2">
                                <div class="col">
                                    <select class="form-select team-select" onchange="updateEmailDropdown(this)">
                                        <option value="">Select Team</option>
                                    </select>
                                </div>
                                <div class="col">
                                    <select class="form-select email-select" disabled>
                                        <option value="">Select Email</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <button id="addCoEditorBtn" class="btn btn-primary mt-2">+</button>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" id="saveCoEditorsBtn">Invite</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const modal = new bootstrap.Modal(document.getElementById('inviteCoEditorModal'));
    modal.show();

    // Populate team dropdown
    await populateTeamDropdown(teamsTableName);

    // Add more co-editor entries
    document.getElementById('addCoEditorBtn').onclick = async () => {
        const newEntry = `
            <div class="co-editor-entry row mb-2">
                <div class="col">
                    <select class="form-select team-select" onchange="updateEmailDropdown(this)">
                        <option value="">Select Team</option>
                    </select>
                </div>
                <div class="col">
                    <select class="form-select email-select" disabled>
                        <option value="">Select Email</option>
                    </select>
                </div>
            </div>
        `;
        document.getElementById('coEditorEntries').insertAdjacentHTML('beforeend', newEntry);
        await populateTeamDropdown(teamsTableName, document.querySelector('.co-editor-entry:last-child .team-select'));
    };

    // Save co-editors
    document.getElementById('saveCoEditorsBtn').onclick = async () => {
        const entries = document.querySelectorAll('.co-editor-entry');
        const coEditors = [];
        entries.forEach(entry => {
            const team = entry.querySelector('.team-select').value;
            const email = entry.querySelector('.email-select').value;
            if (team && email) coEditors.push({ team, email });
        });

        if (coEditors.length === 0) {
            alert('Please select at least one team and email to invite.');
            return;
        }

        try {
            // Create the codrafts table if it doesn't exist
            const codraftsTableName = `${organisationName.replace(/\s+/g, '_')}_codrafts`;
            await createCodraftsTableIfNotExists(codraftsTableName);

            // Fetch contract details
            const contractsTableName = `${organisationName.replace(/\s+/g, '_')}_contracts`;
            const { data: contractData, error: contractError } = await supabaseClient
                .from(contractsTableName)
                .select('title, stage, status,storage_path')
                .eq('cid', cid)
                .limit(1)
                .single();
            if (contractError || !contractData) {
                throw new Error(`Failed to fetch contract details: ${contractError?.message || 'No data found'}`);
            }

            // Fetch the logged-in user's name from the users table
            const loggedInUsername = localStorage.getItem('loggedInAdminUsername');
            const { data: userData, error: userError } = await supabaseClient
                .from('users')
                .select('name')
                .eq('username', loggedInUsername)
                .single();
            if (userError || !userData) {
                throw new Error(`Failed to fetch user details: ${userError?.message || 'No data found'}`);
            }

            const requestedBy = userData.name;
            const title = contractData.title;
            const stage = contractData.stage;
            const status = contractData.status;
            const storagePath = contractData.storage_path;
            const now = new Date().toISOString();

            // Prepare co-draft entries
            const codraftEntries = coEditors.map(coEditor => ({
                cid: cid,
                title: title,
                requested_by: requestedBy,
                requested_to: coEditor.email,
                team: coEditor.team,
                createdon: now,
                updatedon: now,
                stage: stage,
                status: status,
                storage_path: storagePath
            }));

            // Insert into codrafts table
            const { error: insertError } = await supabaseClient
                .from(codraftsTableName)
                .insert(codraftEntries);
            if (insertError) {
                throw new Error(`Failed to insert co-draft entries: ${insertError.message}`);
            }

            console.log('Co-editors invited and saved:', codraftEntries);
            alert('Co-editors invited successfully!');
            modal.hide();
        } catch (err) {
            console.error('Error inviting co-editors:', err);
            alert(`Error: ${err.message}`);
        }
    };

    document.getElementById('inviteCoEditorModal').addEventListener('hidden.bs.modal', () => {
        document.getElementById('inviteCoEditorModal').remove();
    });
}

// Helper function to create the codrafts table if it doesn't exist
async function createCodraftsTableIfNotExists(tableName) {
    try {
        const { data: tableExists, error: checkError } = await supabaseClient
            .rpc('check_contacts_table_exists', { table_name: tableName });
        if (checkError) throw new Error(`Error checking table existence: ${checkError.message}`);
        if (!tableExists) {
            const { error: createError } = await supabaseClient.rpc('run_contacts_sql', {
                sql_statement: `
                    CREATE TABLE ${tableName} (
                        serial SERIAL PRIMARY KEY,
                        cid TEXT NOT NULL,
                        title TEXT NOT NULL,
                        requested_by TEXT NOT NULL,
                        requested_to TEXT NOT NULL,
                        team TEXT NOT NULL,
                        createdon TIMESTAMP NOT NULL,
                        updatedon TIMESTAMP NOT NULL,
                        stage TEXT NOT NULL,
                        status TEXT NOT NULL,
                        storage_path TEXT
                    );
                `
            });
            if (createError) throw new Error(`Failed to create table ${tableName}: ${createError.message}`);
            console.log(`Created codrafts table: ${tableName}`);
        }
    } catch (err) {
        console.error('Error creating codrafts table:', err);
        throw err;
    }
}

// Populate team dropdown
async function populateTeamDropdown(teamsTableName, selectElement = document.querySelector('.team-select')) {
    console.log('Populating team dropdown for table:', teamsTableName);
    console.log('Organisation name from localStorage:', localStorage.getItem('loggedInOrganisationName'));

    const { data: teams, error } = await supabaseClient
        .from(teamsTableName)
        .select('team_name')
        
    if (error) {
        console.error('Error fetching teams:', error.message);
        console.error('Error details:', error);
        alert('Failed to load teams: ' + error.message);
        return;
    }

    if (!teams || teams.length === 0) {
        console.warn('No teams found for organisation:', localStorage.getItem('loggedInOrganisationName'));
        selectElement.innerHTML = '<option value="">No teams available</option>';
        return;
    }

    console.log('Teams fetched:', teams);
    teams.forEach(team => {
        const option = document.createElement('option');
        option.value = team.team_name;
        option.textContent = team.team_name;
        selectElement.appendChild(option);
    });
}

// Update email dropdown based on selected team
async function updateEmailDropdown(teamSelect) {
    const emailSelect = teamSelect.parentElement.nextElementSibling.querySelector('.email-select');
    emailSelect.innerHTML = '<option value="">Select Email</option>';
    emailSelect.disabled = true;

    if (!teamSelect.value) return;

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    const { data: users, error } = await supabaseClient
        .from('users')
        .select('email')
        .eq('organisation', organisationName)
        .eq('team_type', teamSelect.value);
    if (error) {
        console.error('Error fetching emails:', error);
        return;
    }

    emailSelect.disabled = false;
    users.forEach(user => {
        const option = document.createElement('option');
        option.value = user.email;
        option.textContent = user.email;
        emailSelect.appendChild(option);
    });
}

async function createContractsTableIfNotExists(tableName) {
    try {
        const { data: tableExists, error: checkError } = await supabaseClient
            .rpc('check_contacts_table_exists', { table_name: tableName });
        if (checkError) throw new Error(`Error checking table existence: ${checkError.message}`);
        if (!tableExists) {
            const { error: createError } = await supabaseClient.rpc('run_contacts_sql', {
                sql_statement: `
                    CREATE TABLE ${tableName} (
                        id SERIAL PRIMARY KEY,
                        cid TEXT NOT NULL,
                        title TEXT NOT NULL,
                        accountname TEXT NOT NULL,
                        createdon TIMESTAMP NOT NULL,
                        updatedon TIMESTAMP NOT NULL,
                        stage TEXT DEFAULT 'Draft',
                        status TEXT DEFAULT 'In Progress',
                        wid TEXT NOT NULL,
                        template TEXT NOT NULL,
                        storage_path TEXT,
                        storage_path_pdf TEXT,
                        valid TEXT DEFAULT 'Pending',
                        sequence INTEGER,
                        team TEXT,
                        email TEXT,
                        work TEXT,
                        iapprovedby TEXT,
                        approved_email TEXT,
                        isignedby TEXT,
                        signed_email TEXT,
                        requested_by TEXT,
                        requested_team TEXT,
                        new_storage_path TEXT,
                        new_storage_path_pdf TEXT
                    );
                `
            });
            if (createError) throw new Error(`Failed to create table ${tableName}: ${createError.message}`);
            const orgName = tableName.split('_contracts')[0];
            const previousVersionsTable = `${orgName}_previousversions`;
            const triggerSql = `
                CREATE OR REPLACE FUNCTION update_contract_step_trigger()
                RETURNS TRIGGER AS $$
                DECLARE
                    all_done boolean;
                    next_id integer;
                    next_email text;
                    next_work text;
                    new_stage text;
                    previous_versions_table text := '${previousVersionsTable}';
                    contract_row RECORD;
                BEGIN
                    RAISE NOTICE 'Trigger fired for cid: %, valid: % -> %, stage: %', NEW.cid, OLD.valid, NEW.valid, NEW.stage;
                    
                    -- Check if all steps are done
                    SELECT NOT EXISTS (
                        SELECT 1 FROM ${tableName}
                        WHERE cid = NEW.cid AND valid = 'Pending'
                    ) INTO all_done;

                    IF all_done THEN
                        RAISE NOTICE 'All steps completed for cid: %, updating stage to Completed', NEW.cid;
                        -- Update storage paths in the database for all rows with this cid
                        UPDATE ${tableName}
                        SET 
                            stage = 'Completed',
                            status = 'Completed',
                            updatedon = NOW()
                        WHERE cid = NEW.cid;

                        -- Check if previous versions table exists, create if not
                        PERFORM 1 FROM pg_tables WHERE schemaname = 'public' AND tablename = previous_versions_table;
                        IF NOT FOUND THEN
                            EXECUTE format('
                                CREATE TABLE %I (
                                    id SERIAL PRIMARY KEY,
                                    cid TEXT NOT NULL,
                                    title TEXT NOT NULL,
                                    accountname TEXT NOT NULL,
                                    storage_path TEXT,
                                    storage_path_pdf TEXT,
                                    requested_by TEXT,
                                    requested_team TEXT,
                                    created_on TIMESTAMP NOT NULL,
                                    updated_on TIMESTAMP NOT NULL
                                )', previous_versions_table);
                            RAISE NOTICE 'Created previous versions table: %', previous_versions_table;
                        END IF;

                        -- Select one row for the cid to insert into previous versions table
                        SELECT cid, title, accountname, storage_path, storage_path_pdf, 
                               requested_by, requested_team, createdon, updatedon 
                        INTO contract_row
                        FROM ${tableName}
                        WHERE cid = NEW.cid
                        LIMIT 1;

                        -- Insert into previous versions table
                        EXECUTE format('
                            INSERT INTO %I (
                                cid, title, accountname, storage_path, storage_path_pdf,
                                requested_by, requested_team, created_on, updated_on
                            ) VALUES (
                                $1, $2, $3, $4, $5, $6, $7, $8, $9
                            )', previous_versions_table)
                        USING contract_row.cid, contract_row.title, contract_row.accountname,
                              contract_row.storage_path, contract_row.storage_path_pdf,
                              contract_row.requested_by, contract_row.requested_team,
                              contract_row.createdon, contract_row.updatedon;

                        RAISE NOTICE 'Inserted row into previous versions table for cid: %', NEW.cid;

                        -- Update storage_path and storage_path_pdf to new_storage_path and new_storage_path_pdf
                        UPDATE ${tableName}
                        SET 
                            storage_path = new_storage_path,
                            storage_path_pdf = new_storage_path_pdf
                        WHERE cid = NEW.cid
                        AND new_storage_path IS NOT NULL
                        AND new_storage_path_pdf IS NOT NULL;

                        RAISE NOTICE 'Updated storage paths to new_storage_path and new_storage_path_pdf for cid: %', NEW.cid;

                    ELSIF NEW.valid = 'Done' AND OLD.valid = 'Pending' THEN
                        -- Get the next pending row
                        SELECT id, email, work INTO next_id, next_email, next_work
                        FROM ${tableName}
                        WHERE cid = NEW.cid AND valid = 'Pending'
                        ORDER BY id ASC LIMIT 1;

                        RAISE NOTICE 'Next step id: %, email: %, work: %', next_id, next_email, next_work;

                        IF next_id IS NOT NULL THEN
                            -- Specific conditions for Extension Draft stages
                            IF NEW.stage = 'Extension Draft – External Approval' AND next_email IS NULL AND next_work = 'approval' THEN
                                new_stage := 'Extension Draft - Internal Approval';
                            ELSIF NEW.stage = 'Extension Draft – External Approval' AND next_email IS NOT NULL AND next_work = 'signature' THEN
                                new_stage := 'Extension Draft - External Signature';
                            ELSIF NEW.stage = 'Extension Draft – ExternalΛ Approval' AND next_email IS NULL AND next_work = 'signature' THEN
                                new_stage := 'Extension Draft - Internal Signature';
                            ELSIF NEW.stage = 'Extension Draft - Internal Approval' AND next_email IS NULL AND next_work = 'approval' THEN
                                new_stage := 'Extension Draft - Internal Approval';
                            ELSIF NEW.stage = 'Extension Draft - Internal Approval' AND next_email IS NOT NULL AND next_work = 'approval' THEN
                                new_stage := 'Extension Draft - External Approval';
                            ELSIF NEW.stage = 'Extension Draft - Internal Approval' AND next_email IS NOT NULL AND next_work = 'signature' THEN
                                new_stage := 'Extension Draft - External Signature';
                            ELSIF NEW.stage = 'Extension Draft - Internal Approval' AND next_email IS NULL AND next_work = 'signature' THEN
                                new_stage := 'Extension Draft - Internal Signature';
                            ELSIF NEW.stage = 'Extension Draft - External Signature' AND next_email IS NULL AND next_work = 'signature' THEN
                                new_stage := 'Extension Draft - Internal Signature';
                            ELSIF NEW.stage = 'Extension Draft - Internal Signature' AND next_email IS NOT NULL AND next_work = 'signature' THEN
                                new_stage := 'Extension Draft - External Signature';
                            ELSIF NEW.stage = 'Extension Draft - Internal Signature' AND next_email IS NULL AND next_work = 'signature' THEN
                                new_stage := 'Extension Draft - Internal Signature';
                            ELSIF next_email IS NOT NULL AND next_work = 'approval' THEN
                                new_stage := 'Under Review – External';
                            ELSIF next_email IS NOT NULL AND next_work = 'signature' THEN
                                new_stage := 'Pending Signature – External';
                            ELSIF next_email IS NULL AND next_work = 'approval' THEN
                                new_stage := 'Under Review – Internal';
                            ELSIF next_email IS NULL AND next_work = 'signature' THEN
                                new_stage := 'Pending Signature – Internal';
                            END IF;

                            IF new_stage IS NOT NULL THEN
                                RAISE NOTICE 'Updating next step id: % to stage: %', next_id, new_stage;
                                UPDATE ${tableName}
                                SET stage = new_stage, status = 'In Progress', updatedon = NOW()
                                WHERE id = next_id;
                            ELSE
                                RAISE NOTICE 'No stage update for next step id: % (no matching condition)', next_id;
                            END IF;
                        ELSE
                            RAISE NOTICE 'No next step found for cid: %', NEW.cid;
                        END IF;
                    END IF;
                    RETURN NEW;
                END;
                $$ LANGUAGE plpgsql;

                CREATE TRIGGER on_valid_update
                AFTER UPDATE OF valid ON ${tableName}
                FOR EACH ROW EXECUTE FUNCTION update_contract_step_trigger();
            `;
            const { error: triggerError } = await supabaseClient.rpc('run_contacts_sql', { sql_statement: triggerSql });
            if (triggerError) throw new Error(`Failed to create trigger for ${tableName}: ${triggerError.message}`);

            console.log(`Created contracts table and trigger: ${tableName}`);
        }
    } catch (err) {
        console.error('Error creating contracts table or trigger:', err);
        throw err;
    }
}

const processedCids = new Set();
const pendingCids = new Set(); // Track CIDs being processed

async function processContractMetadata(cid, contractsTable) {
    if (processedCids.has(cid) || pendingCids.has(cid)) {
        console.log(`Cid ${cid} already processed or pending, skipping`);
        return;
    }
    pendingCids.add(cid);
    console.log(`Processing metadata for cid: ${cid}, table: ${contractsTable}`);
    try {
        const orgName = contractsTable.split('_contracts')[0];
        const metadataTable = `${orgName}_metadatacontract`;

        // Check if metadata table exists
        console.log(`Checking if metadata table ${metadataTable} exists`);
        const { data: tableCheck, error: tableCheckError } = await supabaseClient
            .rpc('run_contacts_sql', {
                sql_statement: `
                    SELECT EXISTS (
                        SELECT FROM pg_tables 
                        WHERE schemaname = 'public' 
                        AND tablename = '${metadataTable}'
                    ) AS table_exists;
                `
            });
        if (tableCheckError) {
            throw new Error(`Error checking table existence: ${tableCheckError.message}`);
        }
        const tableExists = tableCheck?.[0]?.table_exists || false;

        if (!tableExists) {
            console.log(`Creating metadata table ${metadataTable}`);
            const { error: createError } = await supabaseClient.rpc('run_contacts_sql', {
                sql_statement: `
                    CREATE TABLE public.${metadataTable} (
                        cid TEXT PRIMARY KEY,
                        contracttitle TEXT,
                        partya_name TEXT,
                        partya_address TEXT,
                        partyb_name TEXT,
                        partyb_address TEXT,
                        contractdate TEXT,
                        effectivedate TEXT,
                        expirationdate TEXT,
                        contractduration TEXT,
                        payment_amount TEXT,
                        currency TEXT,
                        payment_frequency TEXT,
                        paymentduedate TEXT,
                        noticeperiod TEXT,
                        terminationconditions TEXT,
                        governinglaw TEXT,
                        confidentialityclause TEXT,
                        autorenewal TEXT,
                        renewalnoticeperiod TEXT,
                        specialconditions TEXT,
                        partya_signatory TEXT,
                        partyb_signatory TEXT
                    );
                `
            });
            if (createError) {
                if (createError.message.includes('already exists')) {
                    console.log(`Table ${metadataTable} already exists, proceeding`);
                } else {
                    throw new Error(`Failed to create metadata table: ${createError.message}`);
                }
            } else {
                console.log(`Metadata table ${metadataTable} created successfully`);
            }
        }

        // Check if metadata already exists
        const { data, error } = await supabaseClient
            .from(metadataTable)
            .select('cid')
            .eq('cid', cid)
            .single();
        if (error && error.code !== 'PGRST116') {
            throw new Error(`Error checking existing metadata: ${error.message}`);
        }

        // Fetch storage path
        console.log(`Fetching storage_path for cid: ${cid}`);
        const { data: contractData, error: fetchError } = await supabaseClient
            .from(contractsTable)
            .select('storage_path')
            .eq('cid', cid)
            .limit(1)
            .single();
        if (fetchError || !contractData) {
            throw new Error(`No storage path found for cid: ${cid}`);
        }
        const docPath = contractData.storage_path;
        console.log(`Storage path: ${docPath}`);

        // Fetch document
        const serverUrl = 'http://192.168.4.37:3000';
        const url = `${serverUrl}${docPath}`;
        console.log(`Fetching document from: ${url}`);
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + jwt.sign({}, 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr')
            }
        });
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Document fetch error: ${errorText}`);
            throw new Error(`Failed to fetch document, status: ${response.status}`);
        }
        const docContent = await response.blob();
        console.log('Fetched document size:', docContent.size, 'type:', docContent.type);

        // Convert Blob to ArrayBuffer
        console.log('Converting Blob to ArrayBuffer');
        const arrayBuffer = await docContent.arrayBuffer();

        // Convert .docx to text
        console.log('Converting .docx to text');
        const conversionResponse = await fetch(`${serverUrl}/api/convert-docx`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/octet-stream'
            },
            body: arrayBuffer
        });
        if (!conversionResponse.ok) {
            const errorText = await conversionResponse.text();
            console.error('Conversion response error:', errorText);
            throw new Error(`Failed to convert document, status: ${conversionResponse.status}, details: ${errorText}`);
        }
        const docText = await conversionResponse.text();
        console.log('Extracted text (first 500 chars):', docText.substring(0, 500));

        // Call OpenAI API
        const apiKey = import.meta.env.VITE_OPENAI_KEY;
        console.log('Sending document to OpenAI API');
        const maxRetries = 5;
        let retryCount = 0;
        let apiResponse;
        while (retryCount < maxRetries) {
            try {
                apiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [
                            {
                                role: 'system',
                                content: `You are provided with the text content of a contract document. Extract the following parameters in JSON format. If a field is missing or unclear, set it to null. Do not invent or guess values unless explicitly stated in the document. The document is a Word (.docx) file converted to text, so focus on the textual content and ignore formatting or metadata. Return the result in the exact JSON structure below:

                                {
                                    "ContractTitle": "<Title or null>",
                                    "PartiesInvolved": {
                                        "PartyA": {"Name": "<Name or null>", "Address": "<Address or null>"},
                                        "PartyB": {"Name": "<Name or null>", "Address": "<Address or null>"}
                                    },
                                    "ContractDate": "<YYYY-MM-DD or null>",
                                    "EffectiveDate": "<YYYY-MM-DD or null>",
                                    "ExpirationDate": "<YYYY-MM-DD or null>",
                                    "ContractDuration": "<Duration (e.g., '1 year') or null>",
                                    "PaymentTerms": {
                                        "Amount": "<Amount (e.g., '5000') or null>",
                                        "Currency": "<Currency (e.g., 'USD') or null>",
                                        "Frequency": "<Frequency (e.g., 'Monthly') or null>",
                                        "PaymentDueDate": "<Due Date (e.g., '1st of each month') or null>"
                                    },
                                    "TerminationClause": {
                                        "NoticePeriod": "<Period (e.g., '30 days') or null>",
                                        "TerminationConditions": "<Conditions or null>"
                                    },
                                    "GoverningLaw": "<Law (e.g., 'California') or null>",
                                    "ConfidentialityClause": "<Clause text or null>",
                                    "RenewalTerms": {
                                        "AutoRenewal": "<Yes/No or null>",
                                        "RenewalNoticePeriod": "<Period (e.g., '30 days') or null>"
                                    },
                                    "SpecialConditions": "<Conditions or null>",
                                    "Signatories": {
                                        "PartyA_Signatory": "<Name & Title or null>",
                                        "PartyB_Signatory": "<Name & Title or null>"
                                    }
                                }`
                            },
                            { role: 'user', content: docText }
                        ],
                        response_format: { type: 'json_object' }
                    })
                });
                if (apiResponse.ok) {
                    break;
                }
                if (apiResponse.status === 429) {
                    retryCount++;
                    const delay = Math.pow(2, retryCount) * 2000;
                    console.log(`Rate limit hit, retrying after ${delay}ms (attempt ${retryCount}/${maxRetries})`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    const errorText = await apiResponse.text();
                    console.error(`OpenAI API error: ${errorText}`);
                    throw new Error(`OpenAI API call failed, status: ${apiResponse.status}`);
                }
            } catch (err) {
                if (retryCount === maxRetries - 1) {
                    throw err;
                }
                retryCount++;
                const delay = Math.pow(2, retryCount) * 2000;
                console.log(`Error, retrying after ${delay}ms (attempt ${retryCount}/${maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }

        if (!apiResponse || !apiResponse.ok) {
            throw new Error(`OpenAI API call failed after ${maxRetries} retries`);
        }

        const apiData = await apiResponse.json();
        console.log('OpenAI response:', JSON.stringify(apiData, null, 2));
        if (!apiData.choices || !apiData.choices[0].message.content) {
            throw new Error('No content received from OpenAI API');
        }
        const metadataJson = JSON.parse(apiData.choices[0].message.content);
        console.log('Extracted metadata:', metadataJson);

        // Insert metadata
        const insertData = {
            cid,
            contracttitle: metadataJson.ContractTitle,
            partya_name: metadataJson.PartiesInvolved.PartyA.Name,
            partya_address: metadataJson.PartiesInvolved.PartyA.Address,
            partyb_name: metadataJson.PartiesInvolved.PartyB.Name,
            partyb_address: metadataJson.PartiesInvolved.PartyB.Address,
            contractdate: metadataJson.ContractDate,
            effectivedate: metadataJson.EffectiveDate,
            expirationdate: metadataJson.ExpirationDate,
            contractduration: metadataJson.ContractDuration,
            payment_amount: metadataJson.PaymentTerms.Amount,
            currency: metadataJson.PaymentTerms.Currency,
            payment_frequency: metadataJson.PaymentTerms.Frequency,
            paymentduedate: metadataJson.PaymentTerms.PaymentDueDate,
            noticeperiod: metadataJson.TerminationClause.NoticePeriod,
            terminationconditions: metadataJson.TerminationClause.TerminationConditions,
            governinglaw: metadataJson.GoverningLaw,
            confidentialityclause: metadataJson.ConfidentialityClause,
            autorenewal: metadataJson.RenewalTerms.AutoRenewal,
            renewalnoticeperiod: metadataJson.RenewalTerms.RenewalNoticePeriod,
            specialconditions: metadataJson.SpecialConditions,
            partya_signatory: metadataJson.Signatories.PartyA_Signatory,
            partyb_signatory: metadataJson.Signatories.PartyB_Signatory
        };
        console.log('Data to insert:', insertData);
        // Upsert metadata
        const { error: upsertError } = await supabaseClient
           .from(metadataTable)
           .upsert(insertData, { onConflict: 'cid' });
        if (upsertError) {
            throw new Error(`Failed to upsert metadata: ${upsertError.message}`);
        }
        console.log(`Metadata upserted successfully for cid: ${cid}`);
        processedCids.add(cid);
    } catch (err) {
        console.error(`Error in processContractMetadata for cid: ${cid}:`, err);
        throw err;
    } finally {
        pendingCids.delete(cid);
    }
}

// Populate Template Select
async function populateTemplateSelect(orgName) {
    const templateTableName = `${orgName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_templates`;
    const templateSelect = document.getElementById('templateSelect');
    templateSelect.innerHTML = '<option value="">Select Template</option>';
    try {
        const { data: templates, error } = await supabaseClient
            .from(templateTableName)
            .select('template_name')
            .eq('status', 'published');
        if (error && error.code !== '42P01') throw error;
        if (templates) {
            templates.forEach(template => {
                templateSelect.innerHTML += `<option value="${template.template_name}">${template.template_name}</option>`;
            });
        }
    } catch (err) {
        console.error('Error fetching templates:', err);
    }
}

// Populate Account Select
async function populateAccountSelect(orgName) {
    const accountTableName = `${orgName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_accounts`;
    const accountSelect = document.getElementById('accountSelect');
    accountSelect.innerHTML = '<option value="">Select Account</option>';
    try {
        const { data: accounts, error } = await supabaseClient
            .from(accountTableName)
            .select('name, ac_code');
        if (error && error.code !== '42P01') throw error;
        if (accounts) {
            accounts.forEach(account => {
                accountSelect.innerHTML += `<option value="${account.name}" data-accode="${account.ac_code}">${account.name}</option>`;
            });
        }
    } catch (err) {
        console.error('Error fetching accounts:', err);
    }

    // Handle Account Selection Change
    accountSelect.addEventListener('change', async () => {
        const selectedOption = accountSelect.options[accountSelect.selectedIndex];
        const acCode = selectedOption ? selectedOption.getAttribute('data-accode') : '';
        if (acCode) {
            await populateSignatureAndReceiverSelects(orgName, acCode);
        }
    });
}

// Populate Signature and Receiver Selects
async function populateSignatureAndReceiverSelects(orgName, acCode) {
    const contactTableName = `${orgName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contacts`;
    const signatureSelect = document.getElementById('accountSignatureSelect');
    const receiverSelect = document.getElementById('contractReceiverSelect');
    signatureSelect.innerHTML = '<option value="">Select Signature</option>';
    receiverSelect.innerHTML = '<option value="">Select Receiver</option>';

    const acCodeLast6 = acCode.slice(-6);
    try {
        const { data: contacts, error } = await supabaseClient
            .from(contactTableName)
            .select('email, contact_code')
            .ilike('contact_code', `${acCodeLast6}%`);
        if (error && error.code !== '42P01') throw error;
        if (contacts) {
            contacts.forEach(contact => {
                const option = `<option value="${contact.email}">${contact.email}</option>`;
                signatureSelect.innerHTML += option;
                receiverSelect.innerHTML += option;
            });
        }
    } catch (err) {
        console.error('Error fetching contacts:', err);
    }
}
// Show My Co-Drafts
async function showMyCoDrafts(element) {
    const teamContent = document.getElementById('templatesContent');
    const menuItems = document.querySelectorAll('.menu-item');
    menuItems.forEach(item => item.classList.remove('active'));
    element.parentElement.classList.add('active');

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    if (!organisationName) {
        alert('No admin logged in. Please log in first.');
        window.location.href = 'login.html';
        return;
    }

    const codraftsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_codrafts`;

    teamContent.innerHTML = `
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">My Co-Drafts</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-bordered table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>Agreement Title</th>
                                <th>Requested By</th>
                                <th>Created On</th>
                                <th>Updated On</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="myCoDraftsTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    `;

    await populateMyCoDraftsTable(codraftsTableName);
}

// Populate My Co-Drafts Table
async function populateMyCoDraftsTable(codraftsTableName) {
    const tbody = document.getElementById('myCoDraftsTableBody');
    tbody.innerHTML = '';

    try {
        // Get logged-in user's email
        const loggedInUsername = localStorage.getItem('loggedInAdminUsername');
        const { data: userData, error: userError } = await supabaseClient
            .from('users')
            .select('email')
            .eq('username', loggedInUsername)
            .single();
        if (userError || !userData) {
            throw new Error(`Failed to fetch user email: ${userError?.message || 'No user found'}`);
        }
        const userEmail = userData.email;

        // Fetch co-drafts where requested_to matches the user's email
        const { data: coDraftsData, error } = await supabaseClient
            .from(codraftsTableName)
            .select('cid, title, requested_by, createdon, updatedon')
            .eq('requested_to', userEmail)
            .order('updatedon', { ascending: false });

        if (error) throw new Error(`Failed to fetch co-drafts: ${error.message}`);

        if (coDraftsData && coDraftsData.length > 0) {
            coDraftsData.forEach(draft => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${draft.title}</td>
                    <td>${draft.requested_by}</td>
                    <td>${new Date(draft.createdon).toLocaleString()}</td>
                    <td>${new Date(draft.updatedon).toLocaleString()}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary edit-codraft-btn" data-cid="${draft.cid}">Edit</button>
                    </td>
                `;
                tbody.appendChild(row);

                row.querySelector('.edit-codraft-btn').addEventListener('click', () => {
                    editCoDraft(draft.cid, draft.title);
                });
            });
        } else {
            tbody.innerHTML = '<tr><td colspan="5" class="text-center">No co-drafts found.</td></tr>';
        }
    } catch (err) {
        console.error('Error populating co-drafts table:', err);
        tbody.innerHTML = `<tr><td colspan="5" class="text-center">Error loading co-drafts: ${err.message}</td></tr>`;
    }
}

// Edit Co-Draft Function
async function editCoDraft(cid, title) {
    const organisationName = localStorage.getItem('loggedInOrganisationName');
    const codraftsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_codrafts`;
    const username = localStorage.getItem('loggedInAdminUsername');
    const { data: orgData, error: orgError } = await supabaseClient
        .from('orgadmins')
        .select('org_code')
        .eq('organisation_name', organisationName)
        .single();
    if (orgError || !orgData) {
        alert('Error fetching organization code.');
        return;
    }
    const orgcode = orgData.org_code;

    const { data: codraftData, error } = await supabaseClient
        .from(codraftsTableName)
        .select('storage_path')
        .eq('cid', cid)
        .eq('requested_to', (await supabaseClient.from('users').select('email').eq('username', username).single()).data.email)
        .single();
    if (error || !codraftData) {
        alert('Error fetching co-draft details.');
        return;
    }

    const editorContainer = document.getElementById('fullScreenEditor');
    const templatesContent = document.getElementById('templatesContent');
    const editorButtons = document.getElementById('editorButtons');

    templatesContent.classList.add('hidden');
    editorContainer.style.display = 'block';

    const baseUrl = 'http://192.168.4.37:3000';
    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
    const fileUrl = `${baseUrl}${codraftData.storage_path}`;
    const callbackUrl = `${baseUrl}/sync-draft?tableName=${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts&contractId=${cid}&contractTitle=${encodeURIComponent(title)}&orgcode=${orgcode}&username=${encodeURIComponent(username)}`;

    const config = {
        document: {
            fileType: 'docx',
            title: `${title}.docx`,
            url: fileUrl,
            key: `${cid}`, 
            permissions: { edit: true, download: true }
        },
        documentType: 'word',
        editorConfig: {
            mode: 'edit',
            callbackUrl: callbackUrl,
            user: { id: username, name: username },
            lang: 'en',
            coediting: {
                mode: 'fast', // Enable Fast co-editing mode
                change: true  // Allow immediate change tracking
            }
        },
        events: {
            onReady: () => console.log('Editor is ready'),
            onError: (event) => console.error('Editor error:', event.data),
            onDocumentStateChange: (event) => {
                console.log('Document state changed:', event.data);
                if (event.data && event.data.saved) {
                    console.log('Document changes saved');
                }
            },
            onRequestSaveAs: (event) => console.log('Save as requested:', event.data),
            onCollaborativeChanges: () => console.log('Collaborative changes detected'),
            onInfo: (event) => console.log('Editor info:', event.data)
        },
        height: '100%',
        width: '100%'
    };
    const token = jwt.sign(config, jwtSecret);
    config.token = token;

    if (createEditor) createEditor.destroyEditor();

    editorButtons.innerHTML = `
        <button id="editorCloseBtn" class="btn btn-primary">Close</button>
    `;

    createEditor = new DocsAPI.DocEditor('editorWrapper', config);
    console.log('ONLYOFFICE editor opened with Fast co-editing mode');

    document.getElementById('editorCloseBtn').onclick = () => {
        if (createEditor) {
            createEditor.destroyEditor();
        }
        editorContainer.style.display = 'none';
        templatesContent.classList.remove('hidden');
        showMyCoDrafts(document.getElementById('myCoDraftsLink'));
    };
}
// Define supabaseClient globally (if not already in a separate <script> tag)
// In dashboardlegalteam.html, within DOMContentLoaded (around line 4978)
async function sendExternalReviewEmail(record, contractsTableName) {
    const email = record.email;
    const contractId = record.id;
    const reviewUrl = `${window.location.origin}/external-review.html?email=${encodeURIComponent(email)}&contractId=${encodeURIComponent(contractId)}&table=${encodeURIComponent(contractsTableName)}`;

    console.log('Sending request with:', { toEmail: email, reviewUrl }); // Add this for debugging

    try {
        const response = await fetch('http://192.168.4.37:3000/send-external-review-email', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                toEmail: email,
                reviewUrl: reviewUrl,
            }),
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Server error: ${errorData.error || 'Unknown error'} - Details: ${errorData.details || 'No details'}`);
        }

        console.log('External review email sent to:', email);
    } catch (error) {
        console.error('Error sending external review email:', error);
    }
}

async function initializeDashboard(element) {
    const organisationName = localStorage.getItem('loggedInOrganisationName');
    const username = localStorage.getItem('loggedInAdminUsername');
    if (!organisationName || !username) {
        alert('Please log in first!');
        window.location.href = 'login.html';
        return;
    }

    const { data: userData, error: userError } = await supabaseClient
        .from('users')
        .select('team_type, role, name')
        .eq('username', username)
        .single();
    if (userError || !userData) {
        console.error('Error fetching user details:', userError);
        alert('Error fetching user details.');
        return;
    }

    const team_type = userData.team_type;
    const role = userData.role;
    const name = userData.name;
    const isLegalOrFinancial = team_type === 'Legal Team' || team_type === 'Financial Team';

    // Dynamically add All Accounts tab if needed
    if (isLegalOrFinancial) {
        const dashboardTabs = document.getElementById('dashboardTabs');
        const dashboardTabContent = document.getElementById('dashboardTabContent');
        dashboardTabs.insertAdjacentHTML('beforeend', `
            <li class="nav-item">
                <a class="nav-link" id="all-accounts-tab" data-bs-toggle="tab" href="#all-accounts" role="tab">All Accounts</a>
            </li>
        `);
        dashboardTabContent.insertAdjacentHTML('beforeend', `
            <div class="tab-pane fade all-accounts-tab" id="all-accounts" role="tabpanel">
                <select id="allAccountsSelect" class="form-select mb-3">
                    <option value="">Select Account</option>
                </select>
                <div class="accounts-table">
                    <div class="table-responsive">
                        <table class="table table-bordered table-hover">
                            <thead class="table-light">
                                <tr>
                                    <th>Contract Title</th>
                                    <th>Created On</th>
                                    <th>Updated On</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody id="allAccountsTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        `);
    }

    // Load FullCalendar
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.js';
    script.onload = async () => {
        const calendarEl = document.getElementById('calendar');
        const calendar = new FullCalendar.Calendar(calendarEl, {
            initialView: 'dayGridMonth',
            events: await fetchUpcomingEvents(organisationName),
            eventClick: info => showContractDetails(info.event.extendedProps, organisationName),
            eventContent: arg => {
                const title = arg.event.extendedProps.contracttitle;
                const div = document.createElement('div');
                div.innerHTML = title;
                return { domNodes: [div] };
            }
        });
        calendar.render();
    };
    document.head.appendChild(script);

    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.css';
    document.head.appendChild(link);

    document.getElementById('closePanelBtn').addEventListener('click', () => {
        document.getElementById('contractDetailsPanel').classList.remove('open');
    });

    await populateAccountsDropdown(organisationName, role, team_type, name);
    if (isLegalOrFinancial) {
        await populateAllAccountsDropdown(organisationName);
    }

    document.getElementById('accountSelect').addEventListener('change', async (e) => {
        const accountName = e.target.value;
        if (accountName) {
            await populateDBAccountsTable(organisationName, accountName, role, team_type, name);
        } else {
            document.getElementById('accountsTableBody').innerHTML = '';
        }
    });

    if (isLegalOrFinancial) {
        document.getElementById('allAccountsSelect').addEventListener('change', async (e) => {
            const accountName = e.target.value;
            if (accountName) {
                await populateAllAccountsTable(organizationName, accountName);
            } else {
                document.getElementById('allAccountsTableBody').innerHTML = '';
            }
        });
    }
}
async function showDashboard(element) {
    const menuItems = document.querySelectorAll('.menu-item');
    menuItems.forEach(item => item.classList.remove('active'));
    element.parentElement.classList.add('active');

    const templatesContent = document.getElementById('templatesContent');
    const editorContainer = document.getElementById('fullScreenEditor');
    editorContainer.style.display = 'none';
    templatesContent.classList.remove('hidden');

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    const username = localStorage.getItem('loggedInAdminUsername');
    if (!organisationName || !username) {
        alert('Please log in first!');
        window.location.href = 'login.html';
        return;
    }

    // Fetch user details
    const { data: userData, error: userError } = await supabaseClient
        .from('users')
        .select('team_type, role, name')
        .eq('username', username)
        .single();
    if (userError || !userData) {
        console.error('Error fetching user details:', userError);
        alert('Error fetching user details.');
        return;
    }
    const { team_type, role, name } = userData;
    const isLegalOrFinancial = team_type === 'Legal Team' || team_type === 'Financial Team';

    // Render Dashboard Content
    templatesContent.innerHTML = `
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Dashboard</h5>
            </div>
            <div class="card-body">
                <ul class="nav nav-tabs" id="dashboardTabs" role="tablist">
                    <li class="nav-item">
                        <a class="nav-link active" id="upcoming-events-tab" data-bs-toggle="tab" href="#upcoming-events" role="tab">Upcoming Events</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="accounts-tab" data-bs-toggle="tab" href="#accounts" role="tab">Accounts</a>
                    </li>
                    ${isLegalOrFinancial ? `
                    <li class="nav-item">
                        <a class="nav-link" id="all-accounts-tab" data-bs-toggle="tab" href="#all-accounts" role="tab">All Accounts</a>
                    </li>
                    ` : ''}
                </ul>
                <div class="tab-content" id="dashboardTabContent">
                    <div class="tab-pane fade show active" id="upcoming-events" role="tabpanel">
                        <div class="calendar-container">
                            <div id="calendar"></div>
                            <div class="side-panel" id="contractDetailsPanel">
                                <button class="close-btn" id="closePanelBtn">×</button>
                                <h5>Contract Details</h5>
                                <div class="contract-details" id="contractDetails"></div>
                            </div>
                        </div>
                    </div>
                    <div class="tab-pane fade accounts-tab" id="accounts" role="tabpanel">
                        <select id="accountSelect" class="form-select mb-3">
                            <option value="">Select Account</option>
                        </select>
                        <div class="accounts-table">
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <thead class="table-light">
                                        <tr>
                                            <th>Contract Title</th>
                                            <th>Created On</th>
                                            <th>Updated On</th>
                                            <th>Action</th>
                                        </tr>
                                    </thead>
                                    <tbody id="accountsTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="tab-pane fade all-accounts-tab" id="all-accounts" role="tabpanel">
                        <select id="allAccountsSelect" class="form-select mb-3">
                            <option value="">Select Account</option>
                        </select>
                        <div class="accounts-table">
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <thead class="table-light">
                                        <tr>
                                            <th>Contract Title</th>
                                            <th>Created On</th>
                                            <th>Updated On</th>
                                            <th>Action</th>
                                        </tr>
                                    </thead>
                                    <tbody id="allAccountsTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;

    // Load FullCalendar
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.js';
    script.onload = async () => {
        const calendarEl = document.getElementById('calendar');
        const calendar = new FullCalendar.Calendar(calendarEl, {
            initialView: 'dayGridMonth',
            events: await fetchUpcomingEvents(organisationName),
            eventClick: info => showContractDetails(info.event.extendedProps, organisationName),
            eventContent: arg => {
                const title = arg.event.extendedProps.contracttitle;
                const div = document.createElement('div');
                div.innerHTML = title;
                return { domNodes: [div] };
            }
        });
        calendar.render();
    };
    document.head.appendChild(script);

    // Load FullCalendar CSS
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.css';
    document.head.appendChild(link);

    // Close side panel
    document.getElementById('closePanelBtn').addEventListener('click', () => {
        document.getElementById('contractDetailsPanel').classList.remove('open');
    });

    // Populate Accounts dropdown
    await populateAccountsDropdown(organisationName, role, team_type, name);

    // Populate All Accounts dropdown (if visible)
    if (isLegalOrFinancial) {
        await populateAllAccountsDropdown(organisationName);
    }

    // Handle Accounts dropdown change
    document.getElementById('accountSelect').addEventListener('change', async (e) => {
        const accountName = e.target.value;
        if (accountName) {
            await populateDBAccountsTable(organisationName, accountName, role, team_type, name);
        } else {
            document.getElementById('accountsTableBody').innerHTML = '';
        }
    });

    // Handle All Accounts dropdown change
    if (isLegalOrFinancial) {
        document.getElementById('allAccountsSelect').addEventListener('change', async (e) => {
            const accountName = e.target.value;
            if (accountName) {
                await populateAllAccountsTable(organisationName, accountName);
            } else {
                document.getElementById('allAccountsTableBody').innerHTML = '';
            }
        });
    }
}
async function fetchUpcomingEvents(organisationName) {
    const metadataTable = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_metadatacontract`;
    try {
        const { data, error } = await supabaseClient
            .from(metadataTable)
            .select('cid, contracttitle, expirationdate');
        if (error) throw new Error(`Error fetching metadata: ${error.message}`);
        
        return data
            .filter(item => item.expirationdate)
            .map(item => ({
                title: item.contracttitle,
                start: item.expirationdate,
                extendedProps: { cid: item.cid, contracttitle: item.contracttitle }
            }));
    } catch (err) {
        console.error('Error fetching upcoming events:', err);
        return [];
    }
}

async function showContractDetails(props, organisationName) {
    const metadataTable = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_metadatacontract`;
    try {
        const { data, error } = await supabaseClient
            .from(metadataTable)
            .select('*')
            .eq('cid', props.cid)
            .single();
        if (error) throw new Error(`Error fetching contract details: ${error.message}`);

        const detailsDiv = document.getElementById('contractDetails');
        detailsDiv.innerHTML = `
            <p><strong>Contract Title:</strong> ${data.contracttitle || 'N/A'}</p>
            <p><strong>Party A Name:</strong> ${data.partya_name || 'N/A'}</p>
            <p><strong>Party A Address:</strong> ${data.partya_address || 'N/A'}</p>
            <p><strong>Party B Name:</strong> ${data.partyb_name || 'N/A'}</p>
            <p><strong>Party B Address:</strong> ${data.partyb_address || 'N/A'}</p>
            <p><strong>Contract Date:</strong> ${data.contractdate || 'N/A'}</p>
            <p><strong>Effective Date:</strong> ${data.effectivedate || 'N/A'}</p>
            <p><strong>Expiration Date:</strong> ${data.expirationdate || 'N/A'}</p>
            <p><strong>Contract Duration:</strong> ${data.contractduration || 'N/A'}</p>
            <p><strong>Payment Amount:</strong> ${data.payment_amount || 'N/A'}</p>
            <p><strong>Currency:</strong> ${data.currency || 'N/A'}</p>
            <p><strong>Payment Frequency:</strong> ${data.payment_frequency || 'N/A'}</p>
            <p><strong>Payment Due Date:</strong> ${data.paymentduedate || 'N/A'}</p>
            <p><strong>Notice Period:</strong> ${data.noticeperiod || 'N/A'}</p>
            <p><strong>Termination Conditions:</strong> ${data.terminationconditions || 'N/A'}</p>
            <p><strong>Governing Law:</strong> ${data.governinglaw || 'N/A'}</p>
            <p><strong>Confidentiality Clause:</strong> ${data.confidentialityclause || 'N/A'}</p>
            <p><strong>Auto Renewal:</strong> ${data.autorenewal || 'N/A'}</p>
            <p><strong>Renewal Notice Period:</strong> ${data.renewalnoticeperiod || 'N/A'}</p>
            <p><strong>Special Conditions:</strong> ${data.specialconditions || 'N/A'}</p>
            <p><strong>Party A Signatory:</strong> ${data.partya_signatory || 'N/A'}</p>
            <p><strong>Party B Signatory:</strong> ${data.partyb_signatory || 'N/A'}</p>
        `;

        document.getElementById('contractDetailsPanel').classList.add('open');
    } catch (err) {
        console.error('Error showing contract details:', err);
        alert('Error loading contract details.');
    }
}

async function populateAccountsDropdown(organisationName, role, team_type, name) {
    const contractsTable = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;
    const accountSelect = document.getElementById('accountSelect');
    accountSelect.innerHTML = '<option value="">Select Account</option>';

    try {
        let query = supabaseClient
            .from(contractsTable)
            .select('accountname')
            .eq('stage', 'Completed')
            .eq('status', 'Completed')
            .eq('requested_team', team_type);

        if (role === 'member') {
            query = query.eq('requested_by', name);
        }

        const { data, error } = await query;
        if (error) throw new Error(`Error fetching accounts: ${error.message}`);

        // Ensure unique account names using a Set
        const uniqueAccountNames = [...new Set(data.map(item => item.accountname))];
        
        if (uniqueAccountNames.length > 0) {
            uniqueAccountNames.forEach(accountName => {
                const option = document.createElement('option');
                option.value = accountName;
                option.textContent = accountName;
                accountSelect.appendChild(option);
            });
        }
    } catch (err) {
        console.error('Error populating accounts dropdown:', err);
    }
}

async function populateDBAccountsTable(organisationName, accountName, role, team_type, name) {
    const contractsTable = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;
    const tbody = document.getElementById('accountsTableBody');
    tbody.innerHTML = '';

    try {
        let query = supabaseClient
            .from(contractsTable)
            .select('cid, title, createdon, updatedon, storage_path_pdf')
            .eq('accountname', accountName)
            .eq('stage', 'Completed')
            .eq('status', 'Completed')
            .eq('requested_team', team_type);

        if (role === 'member') {
            query = query.eq('requested_by', name);
        }

        const { data, error } = await query;
        if (error) throw new Error(`Error fetching contracts: ${error.message}`);

        // Group by cid to ensure only one row per cid
        const uniqueContracts = {};
        data.forEach(item => {
            if (!uniqueContracts[item.cid]) {
                uniqueContracts[item.cid] = item;
            }
        });

        const contracts = Object.values(uniqueContracts);
        if (contracts.length > 0) {
            contracts.forEach(contract => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${contract.title}</td>
                    <td>${new Date(contract.createdon).toLocaleString()}</td>
                    <td>${new Date(contract.updatedon).toLocaleString()}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-btn" data-storage-path="${contract.storage_path_pdf}">View</button>
                    </td>
                `;
                tbody.appendChild(row);

                row.querySelector('.view-btn').addEventListener('click', () => {
                    openPDFPreview(contract.storage_path_pdf, contract.title);
                });
            });
        } else {
            tbody.innerHTML = '<tr><td colspan="4" class="text-center">No contracts found.</td></tr>';
        }
    } catch (err) {
        console.error('Error populating accounts table:', err);
        tbody.innerHTML = `<tr><td colspan="4" class="text-center">Error loading contracts: ${err.message}</td></tr>`;
    }
}

async function populateAllAccountsDropdown(organisationName) {
    const contractsTable = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;
    const accountSelect = document.getElementById('allAccountsSelect');
    accountSelect.innerHTML = '<option value="">Select Account</option>';

    try {
        const { data, error } = await supabaseClient
            .from(contractsTable)
            .select('accountname')
            .eq('stage', 'Completed')
            .eq('status', 'Completed');
        if (error) throw new Error(`Error fetching all accounts: ${error.message}`);

        // Ensure unique account names using a Set
        const uniqueAccountNames = [...new Set(data.map(item => item.accountname))];
        
        if (uniqueAccountNames.length > 0) {
            uniqueAccountNames.forEach(accountName => {
                const option = document.createElement('option');
                option.value = accountName;
                option.textContent = accountName;
                accountSelect.appendChild(option);
            });
        }
    } catch (err) {
        console.error('Error populating all accounts dropdown:', err);
    }
}

async function populateAllAccountsTable(organisationName, accountName) {
    const contractsTable = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;
    const tbody = document.getElementById('allAccountsTableBody');
    tbody.innerHTML = '';

    try {
        const { data, error } = await supabaseClient
            .from(contractsTable)
            .select('cid, title, createdon, updatedon, storage_path_pdf')
            .eq('accountname', accountName)
            .eq('stage', 'Completed')
            .eq('status', 'Completed');
        if (error) throw new Error(`Error fetching all contracts: ${error.message}`);

        // Group by cid to ensure only one row per cid
        const uniqueContracts = {};
        data.forEach(item => {
            if (!uniqueContracts[item.cid]) {
                uniqueContracts[item.cid] = item;
            }
        });

        const contracts = Object.values(uniqueContracts);
        if (contracts.length > 0) {
            contracts.forEach(contract => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${contract.title}</td>
                    <td>${new Date(contract.createdon).toLocaleString()}</td>
                    <td>${new Date(contract.updatedon).toLocaleString()}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-btn" data-storage-path="${contract.storage_path_pdf}">View</button>
                    </td>
                `;
                tbody.appendChild(row);

                row.querySelector('.view-btn').addEventListener('click', () => {
                    openPDFPreview(contract.storage_path_pdf, contract.title);
                });
            });
        } else {
            tbody.innerHTML = '<tr><td colspan="4" class="text-center">No contracts found.</td></tr>';
        }
    } catch (err) {
        console.error('Error populating all accounts table:', err);
        tbody.innerHTML = `<tr><td colspan="4" class="text-center">Error loading contracts: ${err.message}</td></tr>`;
    }
}

async function openPDFPreview(storagePath, title) {
    const baseUrl = 'http://192.168.4.37:3000';
    const jwtSecret = 'cgXqlssiSUBIw4imAhbQNRBWr41kaivr';
    const fileUrl = `${baseUrl}${storagePath}`;

    const modalHtml = `
        <div class="modal fade" id="pdfPreviewModal" tabindex="-1" aria-labelledby="pdfPreviewModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="pdfPreviewModalLabel">${title}</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div id="pdf-viewer-container">
                            <canvas id="render-canvas"></canvas>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const modal = new bootstrap.Modal(document.getElementById('pdfPreviewModal'));
    modal.show();

    try {
        const response = await fetch(fileUrl, {
            method: 'GET',
            headers: { 'Authorization': 'Bearer ' + jwt.sign({}, jwtSecret) }
        });
        if (!response.ok) throw new Error(`Failed to fetch PDF: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 1.5 });

        const canvas = document.getElementById('render-canvas');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        const context = canvas.getContext('2d');
        await page.render({ canvasContext: context, viewport }).promise;
    } catch (err) {
        console.error('Error rendering PDF:', err);
        alert('Error loading PDF preview.');
    }

    document.getElementById('pdfPreviewModal').addEventListener('hidden.bs.modal', () => {
        document.getElementById('pdfPreviewModal').remove();
    });
}



document.addEventListener('DOMContentLoaded', async () => {
    console.log('DOM content loaded, starting consolidated initialization');

    // Initialize Supabase client
    if (!supabaseClient) {
        const { supabaseUrl, supabaseKey } = window.ENV;
        supabaseClient = supabase.createClient(
           (supabaseUrl, supabaseKey)
        );
        console.log('Supabase client initialized');
    }

    // Check DOM readiness
    const templatesContent = document.getElementById('templatesContent');
    if (!templatesContent) {
        console.error('Error: #templatesContent not found on page load');
        return;
    }

    if (!window.originalTemplatesContent) {
        window.originalTemplatesContent = templatesContent.innerHTML;
        console.log('window.originalTemplatesContent set:', window.originalTemplatesContent);
    }
    
    const loggedInUser = localStorage.getItem('loggedInAdminUsername');
    console.log('Logged in user:', loggedInUser);

    const organisationName = localStorage.getItem('loggedInOrganisationName');
    if (!organisationName) {
        console.warn('No organisation name found, redirecting to login');
        window.location.href = 'login.html';
        return;
    }

    const templatesTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_templates`;
    const contractsTableName = `${organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}_contracts`;
    console.log('Derived table names:', { templatesTableName, contractsTableName });

    // Fetch org data
    const { data: orgData, error: orgError } = await supabaseClient
        .from('orgadmins')
        .select('org_code')
        .eq('organisation_name', organisationName)
        .single();
    if (orgError) {
        console.error('Error fetching org data:', orgError);
    } else {
        console.log('Org data fetch result:', orgData);
        console.log('Orgcode retrieved:', orgData?.org_code);
    }

    // Real-time subscription for contracts table
    const channelName = `contracts-updates-${contractsTableName}`;
    console.log('Setting up real-time subscription on channel:', channelName);


    let subscriptionAttempt = 0;
    const maxAttempts = 5;
    let contractsSubscription = null;
    let pendingUpdates = new Map(); // Store updates by cid

    async function setupSubscription() {
        if (contractsSubscription) {
            supabaseClient.removeChannel(contractsSubscription);
        }
        subscriptionAttempt++;
        console.log('Subscription attempt:', subscriptionAttempt);

        try {
            contractsSubscription = supabaseClient
                .channel(channelName)
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: contractsTableName
                },async (payload) => {

                    console.log('Real-time update detected:', payload);
                const cid = payload.new.cid;

                // Aggregate updates by cid
                pendingUpdates.set(cid, payload);

                // Debounce processing
                setTimeout(async () => {
                    if (!pendingUpdates.has(cid)) return; // Update already processed
                    pendingUpdates.delete(cid);

                    try {
                        // Fetch all rows for this cid
                        const { data: rows, error } = await supabaseClient
                            .from(contractsTableName)
                            .select('valid, stage, status')
                            .eq('cid', cid);
                        if (error) {
                            console.error(`Error fetching rows for cid: ${cid}:`, error);
                            return;
                        }

                        const allDone = rows.every(row => row.valid === 'Done');
                        const allCompleted = rows.every(row => row.stage === 'Completed' && row.status === 'Completed');
                        console.log(`Cid: ${cid}, All valid Done: ${allDone}, All Completed: ${allCompleted}`);

                        if (allDone && allCompleted && !processedCids.has(cid) && !pendingCids.has(cid)) {
                            console.log(`All conditions met for cid: ${cid}, calling processContractMetadata`);
                            await processContractMetadata(cid, contractsTableName);
                        }
                    } catch (err) {
                        console.error(`Failed to process metadata for cid: ${cid}:`, err);
                    }
                }, 5000); // Increased debounce to 5 seconds
                    console.log('Real-time update detected:', payload);
                    const oldRecord = payload.old;
                    const newRecord = payload.new;

                    console.log('Old record:', oldRecord);
                    console.log('New record:', newRecord);

                    const stageChanged = oldRecord.stage !== newRecord.stage;
                    const statusChanged = oldRecord.status !== newRecord.status;

                    console.log('Stage changed:', stageChanged, 'Status changed:', statusChanged);

                    if (stageChanged || statusChanged) {
                        console.log('Stage or status changed, checking conditions...');
                        if (newRecord.stage === 'Pending Signature – External' && newRecord.status === 'In Progress') {
                            console.log('Condition met, initiating external signature process...');
                            initiateExternalSignatureProcess(newRecord.cid, contractsTableName).catch(err => {
                                console.error('Error in external signature process:', err.message);
                                localStorage.setItem('debugLogs', JSON.stringify({
                                    timestamp: new Date().toISOString(),
                                    message: 'Error in email process',
                                    error: err.message,
                                    stack: err.stack
                                }));
                            });
                        }else if (newRecord.stage === 'Extension Draft - External Signature' && newRecord.status === 'In Progress') {
                            console.log('Condition met, initiating external signature process...');
                            initiateExternalExtensionSignatureProcess(newRecord.cid, contractsTableName).catch(err => {
                                console.error('Error in external signature process:', err.message);
                                localStorage.setItem('debugLogs', JSON.stringify({
                                    timestamp: new Date().toISOString(),
                                    message: 'Error in email process',
                                    error: err.message,
                                    stack: err.stack
                                }));
                            });
                        } else if (newRecord.stage === 'Under Review – External' && newRecord.status === 'In Progress') {
                            console.log('Condition met for external review, sending email and refreshing...');
                            sendExternalReviewEmail(newRecord, contractsTableName);
                        }
                        //if(newRecord.stage!="Completed" && newRecord.status!="Completed")
                        //{
                        // localStorage.setItem('activeTab', 'inProgress');
                        //localStorage.setItem('refreshReason', 'stageStatusChange');
                        //console.log('Reloading page due to stage/status change');
                        //window.location.reload();
                        //}
                    }
                })
                .subscribe((status) => {
                    console.log('Subscription status:', status, 'Attempt:', subscriptionAttempt);
                    if (status === 'SUBSCRIBED') {
                        console.log('Successfully subscribed to real-time updates for', contractsTableName);
                        subscriptionAttempt = 0; // Reset on success
                    } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                        console.error('Subscription failed or closed:', status, 'Details:', supabaseClient.getChannels());
                        localStorage.setItem('debugLogs', JSON.stringify({
                            timestamp: new Date().toISOString(),
                            message: 'Subscription error',
                            status: status,
                            attempt: subscriptionAttempt
                        }));
                        if (subscriptionAttempt < maxAttempts) {
                            console.log('Retrying subscription, attempt:', subscriptionAttempt + 1);
                            setTimeout(setupSubscription, 2000 * subscriptionAttempt); // Exponential backoff
                        } else {
                            console.error('Max subscription attempts reached:', maxAttempts);
                        }
                    }
                });

            // Store the subscription reference
            window.contractsSubscription = contractsSubscription;
        } catch (error) {
            console.error('Subscription setup error:', error.message);
            localStorage.setItem('debugLogs', JSON.stringify({
                timestamp: new Date().toISOString(),
                message: 'Subscription setup error',
                error: error.message
            }));
            if (subscriptionAttempt < maxAttempts) {
                console.log('Retrying subscription due to setup error, attempt:', subscriptionAttempt + 1);
                setTimeout(setupSubscription, 2000 * subscriptionAttempt);
            }
        }
    }

    // Initial subscription setup
    setupSubscription();
    // Handle page load based on active tab
    const activeTab = localStorage.getItem('activeTab');
    const refreshReason = localStorage.getItem('refreshReason');
    console.log('Active tab:', activeTab, 'Refresh reason:', refreshReason);

    if (activeTab === 'inProgress' && refreshReason === 'stageStatusChange') {
        const inProgressLink = document.getElementById('contractsInProgressLink');
        if (inProgressLink) {
            const contractsMenuItem = document.getElementById('contractsLink').parentElement;
            contractsMenuItem.classList.add('active');
            const submenu = contractsMenuItem.querySelector('.menu-sub');
            submenu.style.display = 'block';
            inProgressLink.classList.add('active');
            await showContractsInProgress(inProgressLink);
            console.log('Reopened In Progress tab due to stage/status change');
            localStorage.removeItem('refreshReason');
        }
        else {
            // Fallback to Dashboard
            await initializeDashboard(document.getElementById('dashboardLink'));
            localStorage.setItem('activeTab', 'dashboard');
        }
    } else {
        // Load Dashboard by default
    const dashboardLink = document.getElementById('dashboardLink');
    if (dashboardLink) {
        await showDashboard(dashboardLink);
        localStorage.setItem('activeTab', 'dashboard');
        console.log('Loaded Dashboard by default');
    } else {
        console.error('Dashboard link not found');
        await showTemplates(templatesTableName); // Fallback to Templates
    }
    }

    // Event listeners for navigation
    const navLinks = {
        'dashboardLink': showDashboard,
        'myCoDraftsLink': showMyCoDrafts,
        'workflowLink': showWorkflow,
        'contractsInProgressLink': showContractsInProgress,
        'contractsCompletedLink': showContractsCompleted,
        'templatesLink': () => showTemplates(templatesTableName),
        'reviewersLink': showReviewers,
        'signaturesLink': showSignatures,
        
    };

    Object.entries(navLinks).forEach(([linkId, handler]) => {
        const link = document.getElementById(linkId);
        if (link) {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                handler(this);
                localStorage.setItem('activeTab', linkId.replace('Link', ''));
                localStorage.removeItem('refreshReason');
            });
        }
    });

    // Unsubscribe from real-time updates when navigating away from contracts
    const otherLinks = ['templatesLink', 'partiesLink', 'workflowLink', 'contractsCompletedLink', 'myCoDraftsLink'];
    otherLinks.forEach(linkId => {
        document.getElementById(linkId)?.addEventListener('click', () => {
            if (contractsSubscription) {
                supabaseClient.removeChannel(contractsSubscription);
                console.log('Unsubscribed from contracts real-time updates');
            }
        });
    });

    // Contracts menu toggle
    const contractsLink = document.getElementById('contractsLink');
    contractsLink?.addEventListener('click', function(e) {
        e.preventDefault();
        const menuItem = this.parentElement;
        document.querySelectorAll('.menu-item').forEach(item => item.classList.remove('active'));
        menuItem.classList.add('active');
    });

    // My Approvals menu toggle
    const myApprovalsLink = document.getElementById('myApprovalsLink');
    myApprovalsLink?.addEventListener('click', function(e) {
        e.preventDefault();
        const menuItem = this.parentElement;
        document.querySelectorAll('.menu-item').forEach(item => item.classList.remove('active'));
        menuItem.classList.add('active');
    });

    // General menu toggle
    document.querySelectorAll('.menu-toggle').forEach(toggle => {
        toggle.addEventListener('click', function(e) {
            e.preventDefault();
            const menuItem = this.parentElement;
            const submenu = menuItem.querySelector('.menu-sub');
            menuItem.classList.toggle('active');
            submenu.style.display = submenu.style.display === 'block' ? 'none' : 'block';
        });
    });

    // Parties menu toggle
    const partiesLink = document.getElementById('partiesLink');
    partiesLink?.addEventListener('click', function(e) {
        e.preventDefault();
        const menuItem = this.parentElement;
        const submenu = menuItem.querySelector('.menu-sub');
        const isActive = menuItem.classList.contains('active');
        document.querySelectorAll('.menu-item').forEach(item => item.classList.remove('active'));
        if (!isActive) {
            menuItem.classList.add('active');
            submenu.style.display = 'block';
            showPartiesInternal(document.getElementById('partiesInternalLink'));
        } else {
            menuItem.classList.remove('active');
            submenu.style.display = 'none';
        }
    });

    

    document.getElementById('partiesInternalLink')?.addEventListener('click', function(e) {
        e.preventDefault();
        showPartiesInternal(this);
    });
    document.getElementById('partiesExternalLink')?.addEventListener('click', function(e) {
        e.preventDefault();
        showPartiesExternal(this);
    });

    // Save Template button event listener
    const saveTemplateBtn = document.getElementById('saveTemplateBtn');
    if (saveTemplateBtn) {
        console.log('Save Template button found, attaching event listener');
        saveTemplateBtn.addEventListener('click', async function() {
            console.log('Save Template button clicked');
            const templateName = document.getElementById('templateName').value.trim();
            const version = document.getElementById('versionNumber').value.trim();
            console.log('Form values:', { templateName, version });

            if (!templateName || !version) {
                console.warn('Validation failed: Missing template name or version');
                alert('Please fill in all fields.');
                return;
            }

            const templateId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            console.log('Generated templateId:', templateId);

            pendingTemplate = { 
                templateId, 
                templateName, 
                version, 
                templatesTableName, 
                documentsTableName: organisationName.toLowerCase().replace(/[^a-z0-9_]/g, '_'),
                createdBy: loggedInUser, 
                orgcode: orgData?.org_code 
            };
            console.log('Pending template set:', pendingTemplate);

            const modal = bootstrap.Modal.getInstance(document.getElementById('createTemplateModal'));
            if (modal) {
                console.log('Closing modal');
                modal.hide();
            }

            console.log('Calling openOnlyOfficeEditor');
            openOnlyOfficeEditor(templateId, templateName, version, templatesTableName, orgData?.org_code, true);
        });
    }

    // Dependency check
    console.log('Checking dependencies - Supabase:', !!window.supabase, 'DocsAPI:', !!window.DocsAPI, 'CryptoJS:', !!window.CryptoJS);
    if (window.supabase && window.DocsAPI && window.CryptoJS) {
        console.log('All dependencies loaded, initializing app');
    } else {
        console.warn('Some dependencies missing');
    }
});
async function initiateExternalSignatureProcess(cid, contractsTableName) {
    try {
        console.log('Initiating external signature process for cid:', cid);
        // Fetch the row with the specific cid, stage, status, and valid conditions
        const { data, error } = await supabaseClient
            .from(contractsTableName)
            .select('email, storage_path_pdf')
            .eq('cid', cid)
            .eq('stage', 'Pending Signature – External')
            .eq('status', 'In Progress')
            .eq('valid', 'Pending')
            .single();
        if (error) {
            console.error('Supabase query error:', error.message, 'Details:', error.details);
            return;
        }
        if (!data) {
            console.warn('No data found for cid:', cid);
            return;
        }

        const { email, storage_path_pdf } = data;
        console.log('Fetched data:', { email, storage_path_pdf });
        if (!email || !storage_path_pdf) {
            console.error('Missing email or storage_path:', { email, storage_path_pdf });
            return;
        }

        // Generate OTP and store it (temporary, use secure storage in production)
        const otp = Math.floor(100000 + Math.random() * 900000).toString();
        localStorage.setItem(`otp_${email}`, otp);
        localStorage.setItem(`cid_${email}`, cid);
        localStorage.setItem(`storage_path_pdf_${email}`, storage_path_pdf);

        // Construct and log review URL
        const reviewUrl = `${window.location.origin}/external-signature.html?email=${encodeURIComponent(email)}&cid=${encodeURIComponent(cid)}&table=${encodeURIComponent(contractsTableName)}`;
        console.log('Constructed review URL:', reviewUrl);

        // Send email with review URL
        console.log('Sending POST request to:', 'http://192.168.4.37:3000/send-external-review-email');
        const response = await fetch('http://192.168.4.37:3000/send-external-review-email', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ toEmail: email, reviewUrl: reviewUrl }),
        });
        const responseText = await response.text();
        console.log('Server response:', { status: response.status, body: responseText });
        if (!response.ok) {
            throw new Error(`Failed to send email, status: ${response.status}, body: ${responseText}`);
        }
        console.log('External review email sent to:', email);
    } catch (err) {
        console.error('Error in initiateExternalSignatureProcess:', {
            message: err.message,
            stack: err.stack,
        });
        throw err;
    }
}
async function initiateExternalExtensionSignatureProcess(cid, contractsTableName) {
    try {
        console.log('Initiating external signature process for cid:', cid);
        // Fetch the row with the specific cid, stage, status, and valid conditions
        const { data, error } = await supabaseClient
            .from(contractsTableName)
            .select('email, new_storage_path_pdf')
            .eq('cid', cid)
            .eq('stage', 'Extension Draft - External Signature')
            .eq('status', 'In Progress')
            .eq('valid', 'Pending')
            .single();
        if (error) {
            console.error('Supabase query error:', error.message, 'Details:', error.details);
            return;
        }
        if (!data) {
            console.warn('No data found for cid:', cid);
            return;
        }

        const { email, new_storage_path_pdf } = data;
        console.log('Fetched data:', { email, new_storage_path_pdf });
        if (!email || !new_storage_path_pdf) {
            console.error('Missing email or storage_path:', { email, new_storage_path_pdf });
            return;
        }

        // Generate OTP and store it (temporary, use secure storage in production)
        const otp = Math.floor(100000 + Math.random() * 900000).toString();
        localStorage.setItem(`otp_${email}`, otp);
        localStorage.setItem(`cid_${email}`, cid);
        localStorage.setItem(`new_storage_path_pdf_${email}`, new_storage_path_pdf);

        // Construct and log review URL
        const reviewUrl = `${window.location.origin}/external-signatureextension.html?email=${encodeURIComponent(email)}&cid=${encodeURIComponent(cid)}&table=${encodeURIComponent(contractsTableName)}`;
        console.log('Constructed review URL:', reviewUrl);

        // Send email with review URL
        console.log('Sending POST request to:', 'http://192.168.4.37:3000/send-external-review-email');
        const response = await fetch('http://192.168.4.37:3000/send-external-review-email', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ toEmail: email, reviewUrl: reviewUrl }),
        });
        const responseText = await response.text();
        console.log('Server response:', { status: response.status, body: responseText });
        if (!response.ok) {
            throw new Error(`Failed to send email, status: ${response.status}, body: ${responseText}`);
        }
        console.log('External review email sent to:', email);
    } catch (err) {
        console.error('Error in initiateExternalExtensionSignatureProcess:', {
            message: err.message,
            stack: err.stack,
        });
        throw err;
    }
}
    </script>
</body>
</html>