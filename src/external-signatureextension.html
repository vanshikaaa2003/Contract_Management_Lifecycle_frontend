<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>External Review</title>
    <link rel="stylesheet" href="vuexy-bootstrap-html-admin-template/full-version/dist/css/core.css">
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.js"></script>
    <style>
        #editorButtons {
            margin-bottom: 10px;
        }
        #editorButtons button {
            margin-right: 10px;
        }
    </style>
    <script>
        let supabase = null;

        function initializePdfLib() {
            if (typeof PDFLib === 'undefined') {
                console.error('PDFLib is not defined. Check the pdf-lib script inclusion.');
                alert('Failed to load PDF manipulation library. Please ensure pdf-lib.js is accessible.');
                return false;
            }
            const { PDFDocument, rgb } = PDFLib;
            if (typeof PDFDocument !== 'function') {
                console.error('PDFDocument is not a function or undefined in PDFLib');
                alert('PDF manipulation library loaded incorrectly.');
                return false;
            }
            console.log('PDFLib loaded successfully, PDFDocument available');
            return true;
        }

        function onSupabaseLoaded() {
            console.log('Supabase library loaded successfully');
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeApp);
            } else {
                initializeApp();
            }
        }

        function onSupabaseError() {
            console.error('Failed to load Supabase library. Check network or CDN.');
            alert('Error loading application. Please try again later.');
        }

        async function initializeApp() {
            if (typeof window.supabase === 'undefined' || !window.supabase) {
                console.error('Supabase global not found. Library failed to load.');
                return;
            }
            supabase = window.supabase.createClient(
                '***REMOVED***',
                '***REMOVED***'
            );
            console.log('Supabase client initialized');

            if (!initializePdfLib()) {
                return;
            }

            const urlParams = new URLSearchParams(window.location.search);
            const email = urlParams.get('email');
            const cid = urlParams.get('cid');
            const tableName = urlParams.get('table');

            const emailInput = document.getElementById('emailInput');
            if (!emailInput) {
                console.error('Email input element not found');
                return;
            }
            emailInput.value = email;

            let currentOtp = null;

            async function sendOtp() {
                currentOtp = Math.floor(100000 + Math.random() * 900000).toString();
                const brevoApiKey = '***REMOVED***';
                const senderEmail = 'vanshika.aggarwal@bytewisetl.com';

                try {
                    const response = await fetch('https://api.brevo.com/v3/smtp/email', {
                        method: 'POST',
                        headers: {
                            'accept': 'application/json',
                            'api-key': brevoApiKey,
                            'content-type': 'application/json',
                        },
                        body: JSON.stringify({
                            sender: { name: 'Contract Review Team', email: senderEmail },
                            to: [{ email: email, name: 'External Reviewer' }],
                            subject: 'Your OTP for External Review',
                            htmlContent: `<p>Your OTP is: <strong>${currentOtp}</strong></p>`,
                        }),
                    });

                    if (!response.ok) throw new Error('Failed to send OTP');
                    console.log('OTP sent to:', email);

                    document.getElementById('loginSection').style.display = 'none';
                    document.getElementById('otpSection').style.display = 'block';
                } catch (error) {
                    console.error('Error sending OTP:', error);
                    alert('Failed to send OTP. Please try again later.');
                }
            }

            document.getElementById('sendOtpBtn').addEventListener('click', sendOtp);
            document.getElementById('resendOtpBtn').addEventListener('click', sendOtp);

            document.getElementById('verifyOtpBtn').addEventListener('click', async () => {
                const enteredOtp = document.getElementById('otpInput').value.trim();
                if (enteredOtp === currentOtp) {
                    try {
                        const { data, error } = await supabase
                            .from(tableName)
                            .select('new_storage_path_pdf, title')
                            .eq('cid', cid)
                            .eq('valid', 'Pending')
                            .single();
                        if (error) throw error;
                        if (!data?.new_storage_path_pdf) {
                            console.error('No new_storage_path_pdf found for cid:', cid);
                            alert('Document not found. Contact support.');
                            return;
                        }
                        console.log('Storage path retrieved:', data.new_storage_path_pdf, 'Title:', data.title);

                        document.getElementById('otpSection').style.display = 'none';
                        document.getElementById('pdfContainer').style.display = 'block';

                        const storagePath = data.new_storage_path_pdf;
                        const title = data.title || 'contract';
                        await openPdfPreview(cid, storagePath, title, tableName, email);
                    } catch (error) {
                        console.error('Error verifying OTP or loading document:', error);
                        alert('Error loading document. Please try again.');
                    }
                } else {
                    alert('Invalid OTP');
                }
            });

            async function openPdfPreview(id, storagePath, title, contractsTableName, userEmail) {
                const editorContainer = document.getElementById('editorWrapper');
                const buttonContainer = document.getElementById('editorButtons');
                if (!editorContainer || !buttonContainer) {
                    console.error('editorWrapper or editorButtons not found');
                    return;
                }

                const baseUrl = 'http://192.168.4.37:3000';
                const fileUrl = `${baseUrl}/files${storagePath}`;
                console.log('Document URL:', fileUrl);

                // Test file accessibility
                try {
                    const testResponse = await fetch(fileUrl, { method: 'HEAD' });
                    console.log('File accessibility test status:', testResponse.status, testResponse.statusText);
                    if (!testResponse.ok) throw new Error('File not accessible');
                } catch (testError) {
                    console.error('File accessibility test failed:', testError);
                    alert('Cannot access the document. Check server permissions or URL.');
                    return;
                }

                // Add buttons
                buttonContainer.innerHTML = `
                    <button class="btn btn-primary" id="initiateSignatureBtn">Initiate Signature</button>
                    <button class="btn btn-secondary" id="addCommentBtn">Add Comment</button>
                `;

                // Load PDF in iframe
                const iframe = document.createElement('iframe');
                iframe.src = fileUrl;
                iframe.style.width = '100%';
                iframe.style.height = '600px';
                iframe.style.border = 'none';
                editorContainer.innerHTML = '';
                editorContainer.appendChild(iframe);
                editorContainer.style.display = 'block';

                iframe.onload = () => {
                    console.log('PDF loaded successfully in iframe');
                    // Attach event listeners after iframe loads
                    document.getElementById('initiateSignatureBtn').addEventListener('click', () => {
                        showSignatureOptions(id, cid, storagePath, title, contractsTableName, userEmail, 'external');
                    });
                    document.getElementById('addCommentBtn').addEventListener('click', () => {
                        showCommentPopup(id, cid, contractsTableName);
                    });
                };
                iframe.onerror = (e) => console.error('Iframe load error:', e, 'URL:', fileUrl);
            }

            function showSignatureOptions(id, cid, storagePath, title, contractsTableName, userEmail, team_type) {
                const modalHtml = `
                    <div class="modal fade" id="signatureOptionsModal" tabindex="-1" aria-labelledby="signatureOptionsModalLabel" aria-hidden="true">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="signatureOptionsModalLabel">Initiate Signature</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="radio" name="signatureMethod" id="autoGen" value="auto">
                                        <label class="form-check-label" for="autoGen">Automatic Generation</label>
                                    </div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="radio" name="signatureMethod" id="scratchPad" value="scratch">
                                        <label class="form-check-label" for="scratchPad">Scratch Pad</label>
                                    </div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="radio" name="signatureMethod" id="uploadImage" value="upload">
                                        <label class="form-check-label" for="uploadImage">Upload Image</label>
                                    </div>
                                    <div id="autoGenBox" class="mt-3" style="display: none;">
                                        <input type="text" class="form-control" id="signatureText" placeholder="Enter signature text">
                                    </div>
                                    <div id="scratchPadBox" class="mt-3" style="display: none;">
                                        <canvas id="signatureCanvas" width="300" height="100" style="border: 1px solid #000;"></canvas>
                                    </div>
                                    <div id="uploadImageBox" class="mt-3" style="display: none;">
                                        <input type="file" class="form-control" id="signatureImage" accept="image/*">
                                    </div>
                                    <div id="signaturePlacement" style="display: none; margin-top: 20px;">
                                        <canvas id="placementCanvas"></canvas>
                                        <button id="prevPage">Previous</button>
                                        <button id="nextPage">Next</button>
                                        <button id="confirmPlacement">OK</button>
                                        <button id="cancelPlacement">Cancel</button>
                                    </div>
                                    <div id="previewContainer" style="display: none; margin-top: 20px;">
                                        <h6>Preview of Signed PDF:</h6>
                                        <iframe id="pdfPreview" style="width: 100%; height: 400px; border: 1px solid #ccc;"></iframe>
                                        <button type="button" class="btn btn-primary mt-3" id="finalOkBtn">OK</button>
                                    </div>
                                </div>
                                <div class="modal-footer">
                                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                                    <button type="button" class="btn btn-primary" id="confirmSignatureBtn">OK</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                const modal = new bootstrap.Modal(document.getElementById('signatureOptionsModal'));
                modal.show();

                document.getElementById('autoGen').addEventListener('change', () => {
                    document.getElementById('autoGenBox').style.display = 'block';
                    document.getElementById('scratchPadBox').style.display = 'none';
                    document.getElementById('uploadImageBox').style.display = 'none';
                    document.getElementById('signaturePlacement').style.display = 'none';
                });
                document.getElementById('scratchPad').addEventListener('change', () => {
                    document.getElementById('autoGenBox').style.display = 'none';
                    document.getElementById('scratchPadBox').style.display = 'block';
                    document.getElementById('uploadImageBox').style.display = 'none';
                    document.getElementById('signaturePlacement').style.display = 'none';
                    initSignatureCanvas();
                });
                document.getElementById('uploadImage').addEventListener('change', () => {
                    document.getElementById('autoGenBox').style.display = 'none';
                    document.getElementById('scratchPadBox').style.display = 'none';
                    document.getElementById('uploadImageBox').style.display = 'block';
                    document.getElementById('signaturePlacement').style.display = 'none';
                });

                document.getElementById('confirmSignatureBtn').onclick = async () => {
                    const method = document.querySelector('input[name="signatureMethod"]:checked')?.value;
                    let signatureData = null;

                    if (method === 'auto') {
                        const text = document.getElementById('signatureText').value;
                        if (text) {
                            const canvas = document.createElement('canvas');
                            canvas.width = 150;
                            canvas.height = 50;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = 'black';
                            ctx.font = '20px Arial';
                            ctx.fillText(text, 10, 30);
                            signatureData = canvas.toDataURL('image/png');
                        }
                    } else if (method === 'scratch') {
                        const canvas = document.getElementById('signatureCanvas');
                        signatureData = canvas.toDataURL('image/png');
                    } else if (method === 'upload') {
                        const fileInput = document.getElementById('signatureImage');
                        if (fileInput.files.length > 0) {
                            signatureData = fileInput.files[0];
                        }
                    }

                    if (signatureData) {
                        try {
                            console.log('Starting signature placement with method:', method, 'signatureData type:', typeof signatureData);
                            const modalFooter = document.querySelector('#signatureOptionsModal .modal-footer');
                            const okButton = document.getElementById('confirmSignatureBtn');
                            const cancelButton = modalFooter.querySelector('.btn-secondary[data-bs-dismiss="modal"]');
                            if (okButton && cancelButton) {
                                okButton.style.display = 'none';
                                cancelButton.style.display = 'none';
                            }
                            document.getElementById('signaturePlacement').style.display = 'block';
                            const previewUrl = await placeSignature(cid, storagePath, title, contractsTableName, userEmail, signatureData);
                            console.log('Received preview URL from placeSignature:', previewUrl);

                            const previewContainer = document.getElementById('previewContainer');
                            const pdfPreview = document.getElementById('pdfPreview');
                            if (previewContainer && pdfPreview) {
                                previewContainer.style.display = 'block';
                                pdfPreview.src = previewUrl;
                                pdfPreview.onload = () => console.log('Iframe loaded successfully with URL:', previewUrl);
                                pdfPreview.onerror = (e) => console.error('Iframe load error:', e, 'URL:', previewUrl);
                            } else {
                                console.error('Preview container or pdfPreview element not found in DOM');
                            }
                            alert('Signature added successfully! Preview below. The PDF has been overwritten.');
                            document.getElementById('finalOkBtn').onclick = () => {
                                document.activeElement.blur();
                                const modal = bootstrap.Modal.getInstance(document.getElementById('signatureOptionsModal'));
                                modal.hide();
                            };
                        } catch (error) {
                            console.error('Signature placement error:', error.message, error.stack);
                            alert('Failed to add signature: ' + error.message);
                        }
                    } else {
                        alert('No signature data provided.');
                    }
                };
            }

            function initSignatureCanvas() {
                const canvas = document.getElementById('signatureCanvas');
                const ctx = canvas.getContext('2d');
                let isDrawing = false;
                let lastX = 0;
                let lastY = 0;

                canvas.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    [lastX, lastY] = [e.offsetX, e.offsetY];
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (isDrawing) {
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(e.offsetX, e.offsetY);
                        ctx.stroke();
                        [lastX, lastY] = [e.offsetX, e.offsetY];
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    isDrawing = false;
                });

                canvas.addEventListener('mouseout', () => {
                    isDrawing = false;
                });
            }

            function showCommentPopup(id, cid, contractsTableName) {
                const modalHtml = `
                    <div class="modal fade" id="commentModal" tabindex="-1" aria-labelledby="commentModalLabel" aria-hidden="true">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="commentModalLabel">Add Comment</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <textarea class="form-control" id="commentText" rows="3" placeholder="Enter your comment"></textarea>
                                </div>
                                <div class="modal-footer">
                                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                                    <button type="button" class="btn btn-primary" id="submitCommentBtn">Submit</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                const modal = new bootstrap.Modal(document.getElementById('commentModal'));
                modal.show();

                document.getElementById('submitCommentBtn').onclick = async () => {
                    const comment = document.getElementById('commentText').value.trim();
                    if (comment) {
                        const { error } = await supabase
                            .from(contractsTableName)
                            .update({
                                stage: 'Draft',
                                status: 'In Progress',
                                valid: 'Pending',
                                updatedon: new Date().toISOString()
                            })
                            .eq('cid', cid);
                        if (error) throw error;

                        const { data, error: updateError } = await supabase
                            .from(contractsTableName)
                            .update({ updatedon: new Date().toISOString() })
                            .eq('cid', cid);
                        if (updateError) throw updateError;

                        modal.hide();
                        document.getElementById('commentModal').remove();
                        // showSignatures(document.getElementById('signaturesLink')); // Commented out if not defined
                    }
                };
            }

            const { PDFDocument, rgb } = PDFLib;

            async function placeSignature(cid, storagePath, title, contractsTableName, userEmail, signatureData) {
                console.log('Starting placeSignature with storagePath:', storagePath, 'userEmail:', userEmail, 'signatureData type:', typeof signatureData);

                const pdfUrl = `http://192.168.4.37:3000/files${storagePath}`;
                console.log('Attempting to fetch PDF from:', pdfUrl);
                const response = await fetch(pdfUrl);
                if (!response.ok) {
                    console.error('Fetch failed:', response.status, response.statusText);
                    throw new Error(`Failed to fetch PDF: ${response.statusText}`);
                }
                const pdfBytes = await response.arrayBuffer();
                const pdfDoc = await PDFDocument.load(pdfBytes);

                const form = pdfDoc.getForm();
                const fields = form ? form.getFields() : [];
                let signatureField = null;
                console.log('Extracted fields:', fields.map(f => ({ name: f.getName(), type: f.getType() })));

                for (const field of fields) {
                    if (field instanceof pdfDoc.getForm().SignatureField) {
                        const widget = field.widgets[0];
                        const rect = widget.getRectangle();
                        const fieldName = field.getName();
                        console.log('Signature field found:', fieldName, 'at', rect);
                        if (fieldName.toLowerCase().includes(userEmail.toLowerCase())) {
                            signatureField = { left: rect.x, top: rect.y + rect.height, width: rect.width, height: rect.height };
                            break;
                        }
                    }
                }

                let currentPageIndex = 0;
                let signaturePlaced = false;
                if (!signatureField) {
                    console.log('No matching signature field found, converting to images for manual selection');
                    const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
                    const pdf = await loadingTask.promise;
                    const page = await pdf.getPage(currentPageIndex + 1);
                    const viewport = page.getViewport({ scale: 1.5 });
                    const canvas = document.getElementById('placementCanvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const ctx = canvas.getContext('2d');
                    const renderContext = { canvasContext: ctx, viewport: viewport };
                    await page.render(renderContext).promise;
                    const canvasCenterY = canvas.height / 2;
                    console.log('Canvas dimensions:', { width: canvas.width, height: canvas.height }, 'Center Y:', canvasCenterY);

                    document.getElementById('prevPage').onclick = async () => {
                        if (currentPageIndex > 0) {
                            currentPageIndex--;
                            await renderPage(pdf, currentPageIndex + 1);
                        }
                    };
                    document.getElementById('nextPage').onclick = async () => {
                        if (currentPageIndex < pdf.numPages - 1) {
                            currentPageIndex++;
                            await renderPage(pdf, currentPageIndex + 1);
                        }
                    };

                    try {
                        signatureField = await new Promise((resolve, reject) => {
                            let selectedX = 0, selectedY = 0;
                            const canvas = document.getElementById('placementCanvas');
                            const ctx = canvas.getContext('2d');

                            canvas.addEventListener('click', (event) => {
                                const rect = canvas.getBoundingClientRect();
                                selectedX = event.clientX - rect.left;
                                selectedY = event.clientY - rect.top;
                                console.log('Raw click coordinates (top-down):', { x: selectedX, y: selectedY }, 'Relative to center:', selectedY - canvasCenterY);
                                ctx.beginPath();
                                ctx.rect(selectedX - 75, selectedY, 150, 50);
                                ctx.strokeStyle = 'blue';
                                ctx.stroke();
                            });

                            document.getElementById('confirmPlacement').onclick = () => {
                                if (selectedX && selectedY) {
                                    const field = { left: selectedX - 75, top: selectedY, width: 150, height: 50 };
                                    console.log('Confirmed signature placement at:', field);
                                    document.getElementById('signaturePlacement').style.display = 'none';
                                    resolve(field);
                                } else {
                                    reject(new Error('No click position selected'));
                                }
                            };

                            document.getElementById('cancelPlacement').onclick = () => {
                                document.getElementById('signaturePlacement').style.display = 'none';
                                reject(new Error('Signature placement cancelled by user'));
                            };

                            setTimeout(() => reject(new Error('Signature placement timed out')), 30000);
                        });

                        const page = pdfDoc.getPages()[currentPageIndex];
                        const pdfViewport = page.getSize();
                        console.log('PDF page size:', pdfViewport);
                        let pngData;
                        if (typeof signatureData === 'string' && signatureData.startsWith('data:image/')) {
                            const [mimeType] = signatureData.match(/data:image\/(png|jpeg|jpg)/i) || [];
                            if (!mimeType) throw new Error('Unsupported image format. Only PNG and JPEG are supported.');
                            const base64String = signatureData.replace(/^data:image\/(png|jpeg|jpg);base64,/, '');
                            pngData = Uint8Array.from(atob(base64String), c => c.charCodeAt(0));
                            console.log('Extracted MIME type from base64:', mimeType);
                        } else if (signatureData instanceof Blob) {
                            if (!signatureData.type.startsWith('image/')) throw new Error('Unsupported file type. Please upload a PNG or JPEG image.');
                            const fileReader = new FileReader();
                            pngData = await new Promise((resolve, reject) => {
                                fileReader.onload = (event) => resolve(new Uint8Array(event.target.result));
                                fileReader.onerror = () => reject(new Error('Failed to read uploaded image'));
                                fileReader.readAsArrayBuffer(signatureData);
                            });
                            console.log('Converted Blob to Uint8Array, length:', pngData.length, 'MIME type:', signatureData.type);
                        } else {
                            const canvas = document.createElement('canvas');
                            canvas.width = 150;
                            canvas.height = 50;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = 'black';
                            ctx.font = 'italic 20px Arial';
                            const text = userEmail.split('@')[0] || 'Signature';
                            const textMetrics = ctx.measureText(text);
                            const textX = (canvas.width - textMetrics.width) / 2;
                            const textY = (canvas.height + 20) / 2;
                            ctx.fillText(text, textX, textY);
                            pngData = Uint8Array.from(atob(canvas.toDataURL('image/png').split(',')[1]), c => c.charCodeAt(0));
                            console.log('Auto-generated PNG signature with italic text');
                        }
                        let img;
                        try {
                            if (typeof signatureData === 'string' && /png/i.test(signatureData)) img = await pdfDoc.embedPng(pngData);
                            else if (typeof signatureData === 'string' && /jpeg|jpg/i.test(signatureData)) img = await pdfDoc.embedJpg(pngData);
                            else if (signatureData.type === 'image/png' || signatureData.type === 'image/x-png') img = await pdfDoc.embedPng(pngData);
                            else if (signatureData.type === 'image/jpeg' || signatureData.type === 'image/jpg') img = await pdfDoc.embedJpg(pngData);
                            else img = await pdfDoc.embedPng(pngData);
                            console.log('Embedded image successfully');
                        } catch (error) {
                            console.error('Error embedding image:', error.message, error.stack);
                            throw error;
                        }
                        const scaleX = pdfViewport.width / canvas.width;
                        const scaleY = pdfViewport.height / canvas.height;
                        const adjustedX = signatureField.left * scaleX;
                        const adjustedY = (pdfViewport.height - (signatureField.top * scaleY + signatureField.height * scaleY));
                        console.log('Adjusted coordinates for PDF:', { x: adjustedX, y: adjustedY }, 'Box height:', signatureField.height * scaleY);
                        try {
                            page.drawImage(img, {
                                x: adjustedX,
                                y: adjustedY,
                                width: signatureField.width * scaleX,
                                height: signatureField.height * scaleY,
                                opacity: 1.0
                            });
                            console.log('Image drawn successfully');
                        } catch (error) {
                            console.error('Error drawing image:', error.message, error.stack);
                            throw error;
                        }
                        signaturePlaced = true;
                        console.log('Signature image embedded at adjusted coordinates:', adjustedX, adjustedY);
                    } catch (error) {
                        console.error('Manual selection error:', error.message, error.stack);
                        throw error;
                    }
                }

                if (signatureField && !signaturePlaced) {
                    try {
                        let pngData;
                        if (typeof signatureData === 'string' && signatureData.startsWith('data:image/')) {
                            const [mimeType] = signatureData.match(/data:image\/(png|jpeg|jpg)/i) || [];
                            if (!mimeType) throw new Error('Unsupported image format. Only PNG and JPEG are supported.');
                            const base64String = signatureData.replace(/^data:image\/(png|jpeg|jpg);base64,/, '');
                            pngData = Uint8Array.from(atob(base64String), c => c.charCodeAt(0));
                            console.log('Extracted MIME type from base64:', mimeType);
                        } else if (signatureData instanceof Blob) {
                            if (!signatureData.type.startsWith('image/')) throw new Error('Unsupported file type. Please upload a PNG or JPEG image.');
                            const fileReader = new FileReader();
                            pngData = await new Promise((resolve, reject) => {
                                fileReader.onload = (event) => resolve(new Uint8Array(event.target.result));
                                fileReader.onerror = () => reject(new Error('Failed to read uploaded image'));
                                fileReader.readAsArrayBuffer(signatureData);
                            });
                            console.log('Converted Blob to Uint8Array, length:', pngData.length, 'MIME type:', signatureData.type);
                        } else {
                            const canvas = document.createElement('canvas');
                            canvas.width = 150;
                            canvas.height = 50;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = 'black';
                            ctx.font = 'italic 20px Arial';
                            const text = userEmail.split('@')[0] || 'Signature';
                            const textMetrics = ctx.measureText(text);
                            const textX = (canvas.width - textMetrics.width) / 2;
                            const textY = (canvas.height + 20) / 2;
                            ctx.fillText(text, textX, textY);
                            pngData = Uint8Array.from(atob(canvas.toDataURL('image/png').split(',')[1]), c => c.charCodeAt(0));
                            console.log('Auto-generated PNG signature with italic text');
                        }
                        let img;
                        try {
                            if (typeof signatureData === 'string' && /png/i.test(signatureData)) img = await pdfDoc.embedPng(pngData);
                            else if (typeof signatureData === 'string' && /jpeg|jpg/i.test(signatureData)) img = await pdfDoc.embedJpg(pngData);
                            else if (signatureData.type === 'image/png' || signatureData.type === 'image/x-png') img = await pdfDoc.embedPng(pngData);
                            else if (signatureData.type === 'image/jpeg' || signatureData.type === 'image/jpg') img = await pdfDoc.embedJpg(pngData);
                            else img = await pdfDoc.embedPng(pngData);
                            console.log('Embedded image successfully');
                        } catch (error) {
                            console.error('Error embedding image:', error.message, error.stack);
                            throw error;
                        }
                        page.drawImage(img, {
                            x: signatureField.left,
                            y: signatureField.top - signatureField.height,
                            width: signatureField.width,
                            height: signatureField.height,
                            opacity: 1.0
                        }).catch(error => {
                            console.error('Error drawing image:', error.message, error.stack);
                            throw error;
                        });
                        signaturePlaced = true;
                        console.log('Signature image embedded at:', signatureField.left, signatureField.top - signatureField.height);
                    } catch (error) {
                        console.error('Signature placement error:', error.message, error.stack);
                        throw error;
                    }
                }

                if (!signaturePlaced) {
                    throw new Error('No signature field selected or detected.');
                }

                const updatedPdfBytes = await pdfDoc.save();
                const blob = new Blob([updatedPdfBytes], { type: 'application/pdf' });

                const saveUrl = `http://192.168.4.37:3000/upload`;
                const formData = new FormData();
                const filename = storagePath.split('/').pop() || `${title}.pdf`;
                console.log('Appending file with filename:', filename, 'and path:', storagePath);
                formData.append('file', blob, filename);
                formData.append('path', storagePath);
                console.log('FormData preview:', Array.from(formData.entries()).map(([key, value]) => `${key}: ${value instanceof Blob ? 'Blob' : value.toString().substring(0, 50)}`).join(', '));

                await new Promise(resolve => setTimeout(resolve, 15000));

                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 180000);
                    const saveResponse = await fetch(saveUrl, {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    console.log('Save response status:', saveResponse.status, 'statusText:', saveResponse.statusText);
                    if (!saveResponse.ok) {
                        const errorText = await saveResponse.text();
                        console.error('Save response error:', saveResponse.status, saveResponse.statusText, 'URL:', saveUrl, 'Response text:', errorText);
                        throw new Error(`Failed to save PDF: ${saveResponse.statusText} - ${errorText}`);
                    }
                    console.log('PDF overwritten successfully at:', saveUrl, 'with path:', storagePath);
                } catch (error) {
                    console.error('Fetch error during save:', error.name, error.message, error.stack);
                    throw error;
                }

                const maxAttempts = 5;
                let attempt = 0;
                let fileAvailable = false;
                while (attempt < maxAttempts && !fileAvailable) {
                    try {
                        const checkResponse = await fetch(pdfUrl, { method: 'HEAD' });
                        console.log('File availability check attempt:', attempt + 1, 'Status:', checkResponse.status, 'Status Text:', checkResponse.statusText);
                        if (checkResponse.ok) {
                            fileAvailable = true;
                            console.log('File confirmed available at:', pdfUrl);
                        } else {
                            console.log('File not yet available, attempt:', attempt + 1, 'Waiting 3 seconds...');
                            await new Promise(resolve => setTimeout(resolve, 3000));
                            attempt++;
                        }
                    } catch (error) {
                        console.log('Check failed, attempt:', attempt + 1, 'Error:', error.name, error.message);
                        await new Promise(resolve => setTimeout(resolve, 3000));
                        attempt++;
                    }
                }

                if (!fileAvailable) {
                    console.warn('File not available after max attempts:', maxAttempts, 'Proceeding with potential delay.');
                }

                const { error: dbError } = await supabase
                    .from(contractsTableName)
                    .update({ valid: 'Done', updatedon: new Date().toISOString(), storage_path: storagePath })
                    .eq('cid', cid);
                if (dbError) {
                    console.error('Database update error:', dbError.message);
                    throw dbError;
                }
                console.log('Database updated with storage_path:', storagePath);

                const previewUrl = `${pdfUrl}?t=${Date.now()}`;
                console.log('Returning preview URL:', previewUrl);
                return previewUrl;

                async function renderPage(pdfDoc, pageNum) {
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1.5 });
                    const canvas = document.getElementById('placementCanvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const ctx = canvas.getContext('2d');
                    const renderContext = { canvasContext: ctx, viewport: viewport };
                    await page.render(renderContext).promise;
                }
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js" onload="onSupabaseLoaded()" onerror="onSupabaseError()"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</head>
<body>
    <div class="container">
        <div id="loginSection">
            <h2>External Review Login</h2>
            <div class="mb-3">
                <label for="emailInput" class="form-label">Email</label>
                <input type="email" class="form-control" id="emailInput" readonly>
            </div>
            <button class="btn btn-primary" id="sendOtpBtn">Send OTP</button>
        </div>
        <div id="otpSection" style="display: none;">
            <h2>Verify OTP</h2>
            <div class="mb-3">
                <label for="otpInput" class="form-label">Enter OTP</label>
                <input type="text" class="form-control" id="otpInput">
            </div>
            <button class="btn btn-primary" id="verifyOtpBtn">Verify</button>
            <button class="btn btn-secondary mt-2" id="resendOtpBtn">Resend OTP</button>
        </div>
        <div id="pdfContainer">
            <div id="editorButtons" class="editor-btns"></div>
            <div id="editorWrapper" class="editor-wrapper" style="display: none; height: 600px;"></div>
            <div id="templatesContent"></div>
        </div>
    </div>
    <div id="signaturePopup"></div>
</body>
</html>